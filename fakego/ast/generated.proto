/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = 'proto2';

package github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto;

//import "github.com/gogo/protobuf/gogoproto/gogo.proto";
//import "github.com/h4ck3rm1k3/gogccintro/fakego/ast";

// Package-wide variables from generator "generated".
//option (gogoproto.marshaler_all) = true;
// option (gogoproto.sizer_all) = true;
// option (gogoproto.goproto_stringer_all) = false;
// option (gogoproto.stringer_all) = true;
// option (gogoproto.unmarshaler_all) = true;
// option (gogoproto.goproto_unrecognized_all) = false;
// option (gogoproto.goproto_enum_prefix_all) = false;
// option (gogoproto.goproto_getters_all) = false;
option go_package = "ast";

enum NodeType {
     ARRAYTYPE = 0; // ENUM BASE
     ASSIGNSTMT = 1; // ENUM BASE
     BADDECL = 2; // ENUM BASE
     BADEXPR = 3; // ENUM BASE
     BADSTMT = 4; // ENUM BASE
     BASICLIT = 5; // ENUM BASE
     BINARYEXPR = 6; // ENUM BASE
     BLOCKSTMT = 7; // ENUM BASE
     BRANCHSTMT = 8; // ENUM BASE
     CALLEXPR = 9; // ENUM BASE
    CASECLAUSE = 10; // ENUM BASE
    CHANDIR = 11; // ENUM BASE
    CHANTYPE = 12; // ENUM BASE
    COMMCLAUSE = 13; // ENUM BASE
    COMMENT = 14; // ENUM BASE
    COMPOSITELIT = 15; // ENUM BASE
    DECLSTMT = 16; // ENUM BASE
    DEFERSTMT = 17; // ENUM BASE
    ELLIPSIS = 18; // ENUM BASE
    EMPTYSTMT = 19; // ENUM BASE
    EXPRSTMT = 20; // ENUM BASE
    FIELD = 21; // ENUM BASE
    FIELDLIST = 22; // ENUM BASE
    FILE = 23; // ENUM BASE
    FORSTMT = 24; // ENUM BASE
    FUNCDECL = 25; // ENUM BASE
    FUNCLIT = 26; // ENUM BASE
    FUNCTYPE = 27; // ENUM BASE
    GENDECL = 28; // ENUM BASE
    GOSTMT = 29; // ENUM BASE
    IDENT = 30; // ENUM BASE
    IFSTMT = 31; // ENUM BASE
    IMPORTSPEC = 32; // ENUM BASE
    INCDECSTMT = 33; // ENUM BASE
    INDEXEXPR = 34; // ENUM BASE
    INTERFACETYPE = 35; // ENUM BASE
    ISEXPORTED = 36; // ENUM BASE
    KEYVALUEEXPR = 37; // ENUM BASE
    LABELEDSTMT = 38; // ENUM BASE
    MAPTYPE = 39; // ENUM BASE
    NEWIDENT = 40; // ENUM BASE
    PACKAGE = 41; // ENUM BASE
    PARENEXPR = 42; // ENUM BASE
    RANGESTMT = 43; // ENUM BASE
    RETURNSTMT = 44; // ENUM BASE
    SELECTSTMT = 45; // ENUM BASE
    SELECTOREXPR = 46; // ENUM BASE
    SENDSTMT = 47; // ENUM BASE
    SLICEEXPR = 48; // ENUM BASE
    SPEC = 49; // ENUM BASE
    STAREXPR = 50; // ENUM BASE
    STRUCTTYPE = 51; // ENUM BASE
    SWITCHSTMT = 52; // ENUM BASE
    TYPEASSERTEXPR = 53; // ENUM BASE
    TYPESPEC = 54; // ENUM BASE
    TYPESWITCHSTMT = 55; // ENUM BASE
    UNARYEXPR = 56; // ENUM BASE
    VALUESPEC = 57; // ENUM BASE
    COMMENTGROUP = 58; // ENUM BASE
    OBJECT = 59; // ENUM BASE

    DEFERRED = 60; // extras
    DEFERRED2 = 61; // extras	
}

message ExprStmt {
	required Foo2 X=1; // expression	
}

message StarExpr {}
message DeclStmt {}
message BadDecl {}
message ChanDir {}
message ChanType {}
message Comment {}
message ReturnStmt {}
message IsExported {}
message NewIdent {}
message Node {}



// An AssignStmt node represents an assignment or
// a short variable declaration.
message Expr {
	required NodeType type = 1;
optional BadExpr badexpr = 3; // Interface:Expr
optional BinaryExpr binaryexpr = 6; // Interface:Expr
optional CallExpr callexpr = 9; // Interface:Expr
optional ExprStmt exprstmt = 20; // Interface:Expr
optional IndexExpr indexexpr = 34; // Interface:Expr
optional KeyValueExpr keyvalueexpr = 37; // Interface:Expr
optional ParenExpr parenexpr = 42; // Interface:Expr
optional SelectorExpr selectorexpr = 46; // Interface:Expr
optional SliceExpr sliceexpr = 48; // Interface:Expr
optional StarExpr starexpr = 50; // Interface:Expr
optional TypeAssertExpr typeassertexpr = 53; // Interface:Expr
optional UnaryExpr unaryexpr = 56; // Interface:Expr
}

message Stmt {
	required NodeType type = 1;

optional BadStmt badstmt = 4; // Interface:Stmt
optional BlockStmt blockstmt = 7; // Interface:Stmt
optional BranchStmt branchstmt = 8; // Interface:Stmt
optional DeclStmt declstmt = 16; // Interface:Stmt
optional DeferStmt deferstmt = 17; // Interface:Stmt
optional EmptyStmt emptystmt = 19; // Interface:Stmt
optional ExprStmt exprstmt = 20; // Interface:Stmt
optional ForStmt forstmt = 24; // Interface:Stmt
optional GoStmt gostmt = 29; // Interface:Stmt
optional IfStmt ifstmt = 31; // Interface:Stmt
optional IncDecStmt incdecstmt = 33; // Interface:Stmt
optional LabeledStmt labeledstmt = 38; // Interface:Stmt
optional RangeStmt rangestmt = 43; // Interface:Stmt
optional ReturnStmt returnstmt = 44; // Interface:Stmt
optional SelectStmt selectstmt = 45; // Interface:Stmt
optional SendStmt sendstmt = 47; // Interface:Stmt
optional SwitchStmt switchstmt = 52; // Interface:Stmt
optional TypeSwitchStmt typeswitchstmt = 55; // Interface:Stmt
optional AssignStmt assignstmt = 56; // Interface:Stmt
}

message Decl {
	required NodeType type = 1;
optional BadDecl baddecl = 2; // Interface:Decl
optional DeclStmt declstmt = 16; // Interface:Decl
optional FuncDecl funcdecl = 25; // Interface:Decl
optional GenDecl gendecl = 28; // Interface:Decl

}
message Spec {}
message ImportSpec {}
message CommentGroup {}


message  Foo3{
	 optional int64 tokenpos = 1; 
}


message  Foo2{
	required NodeType type = 1;

optional BadDecl baddecl = 2; // Interface:BASE
optional BadExpr badexpr = 3; // Interface:BASE
optional BadStmt badstmt = 4; // Interface:BASE
optional BasicLit basiclit = 5; // Interface:BASE
optional BinaryExpr binaryexpr = 6; // Interface:BASE
optional BlockStmt blockstmt = 7; // Interface:BASE
optional BranchStmt branchstmt = 8; // Interface:BASE
optional CallExpr callexpr = 9; // Interface:BASE
optional CaseClause caseclause = 10; // Interface:BASE
optional ChanDir chandir = 11; // Interface:BASE
optional ChanType chantype = 12; // Interface:BASE
optional CommClause commclause = 13; // Interface:BASE
optional Comment comment = 14; // Interface:BASE
optional CompositeLit compositelit = 15; // Interface:BASE
optional DeclStmt declstmt = 16; // Interface:BASE
optional DeferStmt deferstmt = 17; // Interface:BASE
optional Ellipsis ellipsis = 18; // Interface:BASE
optional EmptyStmt emptystmt = 19; // Interface:BASE
optional ExprStmt exprstmt = 20; // Interface:BASE
optional Field field = 21; // Interface:BASE
optional FieldList fieldlist = 22; // Interface:BASE
optional File file = 23; // Interface:BASE
optional ForStmt forstmt = 24; // Interface:BASE
optional FuncDecl funcdecl = 25; // Interface:BASE
optional FuncLit funclit = 26; // Interface:BASE
optional FuncType functype = 27; // Interface:BASE
optional GenDecl gendecl = 28; // Interface:BASE
optional GoStmt gostmt = 29; // Interface:BASE
optional Ident ident = 30; // Interface:BASE
optional IfStmt ifstmt = 31; // Interface:BASE
optional ImportSpec importspec = 32; // Interface:BASE
optional IncDecStmt incdecstmt = 33; // Interface:BASE
optional IndexExpr indexexpr = 34; // Interface:BASE
optional InterfaceType interfacetype = 35; // Interface:BASE
optional IsExported isexported = 36; // Interface:BASE
optional KeyValueExpr keyvalueexpr = 37; // Interface:BASE
optional LabeledStmt labeledstmt = 38; // Interface:BASE
optional MapType maptype = 39; // Interface:BASE
optional NewIdent newident = 40; // Interface:BASE
optional Package package = 41; // Interface:BASE
optional ParenExpr parenexpr = 42; // Interface:BASE
optional RangeStmt rangestmt = 43; // Interface:BASE
optional ReturnStmt returnstmt = 44; // Interface:BASE
optional SelectStmt selectstmt = 45; // Interface:BASE
optional SelectorExpr selectorexpr = 46; // Interface:BASE
optional SendStmt sendstmt = 47; // Interface:BASE
optional SliceExpr sliceexpr = 48; // Interface:BASE
optional Spec spec = 49; // Interface:BASE
optional StarExpr starexpr = 50; // Interface:BASE
optional StructType structtype = 51; // Interface:BASE
optional SwitchStmt switchstmt = 52; // Interface:BASE
optional TypeAssertExpr typeassertexpr = 53; // Interface:BASE
optional TypeSpec typespec = 54; // Interface:BASE
optional TypeSwitchStmt typeswitchstmt = 55; // Interface:BASE
optional UnaryExpr unaryexpr = 56; // Interface:BASE
optional ValueSpec valuespec = 57; // Interface:BASE
optional CommentGroup commentgroup = 58; // Interface:BASE
optional AssignStmt assignstmt = 59; // Interface:BASE
optional Object object = 60; // Interface:BASE
optional ArrayType arraytype = 61; // Interface:BASE

optional Deferred deferred = 62; // Interface:BASE

}

message AssignStmt {
  repeated Expr Lhs = 1 ;

  optional Foo3 TokPos = 2 ;

  // position of Tok
  optional Foo3 Tok = 3 ;

  // assignment token, DEFINE
  repeated Expr Rhs = 4 ;
}

message BadExpr {
  optional Foo2 From = 1 ;

  optional Foo2 To = 2 ;
}

// A BadStmt node is a placeholder for statements containing
// syntax errors for which no correct statement nodes can be
// created.
message BadStmt {
  optional Foo2 From = 1 ;

  optional Foo2 To = 2 ;
}

message BasicLit {
  optional Foo3 ValuePos = 1 ;

  optional Foo3 Kind = 2 ;

  optional Foo3 Value = 3 ;
}

// A BinaryExpr node represents a binary expression.
message BinaryExpr {
  optional Foo2 X = 1 ;

  // left operand
  optional Foo3 OpPos = 2 ;

  // position of Op
  optional Foo3 Op = 3 ;

  // operator
  optional Foo2 Y = 4 ;
}

message BlockStmt {
  optional Foo3 Lbrace = 1 ;

  repeated Stmt List = 2 ;

  optional Foo3 Rbrace = 3 ;
}

// A BranchStmt node represents a break, continue, goto,
// or fallthrough statement.
message BranchStmt {
  optional Foo3 TokPos = 1 ;

  optional Foo3 Tok = 2 ;

  // keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)
  optional Ident Label = 3;
}

// A CallExpr node represents an expression followed by an argument list.
message CallExpr {
  optional Foo2 Fun = 1 ;

  // function expression
  optional Foo3 Lparen = 2 ;

  repeated Expr Args = 3 ;

  optional Foo3 Ellipsis = 4 ;

  optional Foo3 Rparen = 5 ;
}

// A CaseClause represents a case of an expression or type switch statement.
message CaseClause {
  optional Foo3 Case = 1 ;

  repeated Expr List = 2 ;

  // list of expressions or types; nil means default case
  optional Foo3 Colon = 3 ;

  repeated Stmt Body = 4 ;
}

// A CommClause node represents a case of a select statement.
message CommClause {
  optional Foo2 Case = 1 ;

  // position of "case" or "default" keyword
  optional Foo2 Comm = 2 ;

  // send or receive statement; nil means default case
  optional Foo2 Colon = 3 ;

  // position of ":"
  repeated Stmt Body = 4 ;
}

// A CompositeLit node represents a composite literal.
message CompositeLit {
  optional Foo2 Type = 1 ;

  // literal type; or nil
  optional Foo3 Lbrace = 2 ;

  repeated Expr Elts = 3 ;

  // []list of composite elements; or nil
  optional Foo3 Rbrace = 4 ;
}

// A DeferStmt node represents a defer statement.
message DeferStmt {
  optional Foo3 Defer = 1 ;

  optional CallExpr Call = 2;
}

// deferred
message Deferred {
  optional string Id = 1 ;

  // Data  Foo2
  // Data  int64
   required NodeType type = 2;
}


// An Ellipsis node stands for the "..." type in a
// parameter list or the "..." length in an array type.
message Ellipsis {
  optional Foo2 Ellipsis = 1 ;

  // position of "..."
  optional Foo2 Elt = 2 ;
}

// An EmptyStmt node represents an empty statement.
// The "position" of the empty statement is the position
// of the immediately following (explicit or implicit) semicolon.
message EmptyStmt {
  optional Foo2 Semicolon = 1 ;

  // position of following ";"
  optional bool Implicit = 2 ;
}

message Field {
  repeated Ident Names = 1;

  optional Foo2 Type = 2 ;

  optional Foo2 Tag = 3 ;
}

message FieldList {
  optional Foo3 Opening = 1 ;

  repeated Field List = 2;

  optional Foo3 Closing = 3 ;
}

message File {
  optional Foo3 Package = 1 ;

  optional Foo3 Name = 2 ;

  repeated Decl Decls = 3 ;

  optional Foo2 Scope = 4 ;

  repeated ImportSpec Imports = 5;

  repeated Ident Unresolved = 6;

  repeated CommentGroup Comments = 7;
}

// A ForStmt represents a for statement.
message ForStmt {
  optional Foo3 For = 1 ;

  // position of "for" keyword
  optional Foo2 Init = 2 ;

  // initialization statement; or nil
  optional Foo2 Cond = 3 ;

  // condition; or nil
  optional Foo2 Post = 4 ;

  // post iteration statement; or nil
  optional Foo2 Body = 5 ;
}

message FuncDecl {
  optional Foo2 Recv = 1 ;

  optional Foo3 Name = 2 ;

  optional Foo2 Type = 3 ;

  optional Foo2 Body = 4 ;
}

// A FuncLit node represents a function literal.
message FuncLit {
  optional FuncType Type = 1;

  // function type
  optional BlockStmt Body = 2;
}

message FuncType {
  optional Foo3 Func = 1 ;

  optional Foo2 Params = 2 ;

  optional FieldList Results = 3;
}

message GenDecl {
  optional Foo3 TokPos = 1 ;

  optional Foo3 Tok = 2 ;

  optional Foo3 Lparen = 3 ;

  repeated Spec Specs = 4 ;

  optional Foo3 Rparen = 5 ;
}

// A GoStmt node represents a go statement.
message GoStmt {
  optional Foo2 Go = 1 ;

  // position of "go" keyword
  optional CallExpr Call = 2;
}

message Ident {
  optional Foo3 NamePos = 1 ;

  optional string Name = 2 ;

  optional Foo2 Obj = 3 ;
}

// An IfStmt node represents an if statement.
message IfStmt {
  optional Foo3 If = 1 ;

  optional Foo2 Init = 2 ;

  // initialization statement; or nil
  optional Foo2 Cond = 3 ;

  // condition
  optional Foo2 Body = 4 ;

  optional Foo2 Else = 5 ;
}

// An IncDecStmt node represents an increment or decrement statement.
message IncDecStmt {
  optional Foo2 X = 1 ;

  optional Foo3 TokPos = 2 ;

  // position of Tok
  optional Foo3 Tok = 3 ;
}

// An IndexExpr node represents an expression followed by an index.
message IndexExpr {
  optional Foo2 X = 1 ;

  // expression
  optional Foo3 Lbrack = 2 ;

  optional Foo2 Index = 3 ;

  // index expression
  optional Foo3 Rbrack = 4 ;
}

message InterfaceType {
  optional Foo3 Interface = 1 ;

  optional FieldList Methods = 2;

  optional bool Incomplete = 3 ;
}

// A KeyValueExpr node represents (key : value) pairs
// in composite literals.
message KeyValueExpr {
  optional Foo2 Key = 1 ;

  optional Foo2 Colon = 2 ;

  // position of ":"
  optional Foo2 Value = 3 ;
}

// A LabeledStmt node represents a labeled statement.
message LabeledStmt {
  optional Ident Label = 1;

  optional Foo2 Colon = 2 ;

  // position of ":"
  optional Foo2 Stmt = 3 ;
}

message MapType {
  optional Foo3 Map = 1 ;

  optional Foo2 Key = 2 ;

  optional Foo2 Value = 3 ;
}

message Object {
  optional Deferred Deferred = 1 ;

  optional Foo3 Kind = 2 ;

  optional Foo3 Name = 3 ;

  optional Foo2 Decl = 4 ;

  optional Foo3 Data = 5 ;
}

message Package {
  optional string Name = 1 ;

  // package name
  optional Foo2 Scope = 2 ;

  // package scope across all files
  map<string, Object> Imports = 3 ;

  // map of package id -> package object
  map<string, File> Files = 4 ;
}

// A ParenFoo2 node represents a parenthesized expression.
message ParenExpr {
  optional Foo3 Lparen = 1 ;

  optional Foo2 X = 2 ;

  // parenthesized expression
  optional Foo3 Rparen = 3 ;
}

// A RangeStmt represents a for statement with a range clause.
message RangeStmt {
  optional Foo3 For = 1 ;

  optional Foo2 Key = 2 ;

  optional Foo2 Value = 3 ;

  // Key, Value may be nil
  optional Foo3 TokPos = 4 ;

  optional Foo3 Tok = 5 ;

  // ILLEGAL if Key == nil, ASSIGN, DEFINE
  optional Foo2 X = 6 ;

  // Expr        // value to range over
  optional Foo2 Body = 7 ;
}

message Scope {
  map<string, Object> Objects = 1 ;
}

// An SelectStmt node represents a select statement.
message SelectStmt {
  optional Foo2 Select = 1 ;

  // position of "select" keyword
  optional Foo2 Body = 2 ;
}

message SelectorExpr {
  optional Foo2 X = 1 ;

  optional Foo2 Sel = 2 ;
}

// A SendStmt node represents a send statement.
message SendStmt {
  optional Foo2 Chan = 1 ;

  optional Foo2 Arrow = 2 ;

  // position of "<-"
  optional Foo2 Value = 3 ;
}

// An SliceExpr node represents an expression followed by slice indices.
message SliceExpr {
  optional Foo2 X = 1 ;

  // expression
  optional Foo3 Lbrack = 2 ;

  optional Foo2 Low = 3 ;

  // begin of slice range; or nil
  optional Foo2 High = 4 ;

  // end of slice range; or nil
  optional Foo2 Max = 5 ;

  // maximum capacity of slice; or nil
  optional bool Slice3 = 6 ;

  // true if 3-index slice (2 colons present)
  optional Foo3 Rbrack = 7 ;
}

message StructType {
  optional Foo3 Struct = 1 ;

  optional FieldList Fields = 2;

  optional bool Incomplete = 3 ;
}

// A SwitchStmt node represents an expression switch statement.
message SwitchStmt {
  optional Foo3 Switch = 1 ;

  // position of "switch" keyword
  optional Foo2 Init = 2 ;

  // initialization statement; or nil
  optional Foo2 Tag = 3 ;

  // tag expression; or nil
  optional Foo2 Body = 4 ;
}

message ArrayType {
	required Foo3 Lbrack =1;
	required Foo2 Elt  =2;
}

// message AddressTable {
//   map<string, Scope> Scopes = 1 ;

//   map<string, Object> Objects = 2 ;

//   map<string, ArrayType> ArrayTypes = 3 ;

//   map<string, AssignStmt> AssignStmts = 4 ;

//   map<string, BadDecl> BadDecls = 5 ;

//   map<string, BadExpr> BadExprs = 6 ;

//   map<string, BadStmt> BadStmts = 7 ;

//   map<string, BasicLit> BasicLits = 8 ;

//   map<string, BinaryExpr> BinaryExprs = 9 ;

//   map<string, BlockStmt> BlockStmts = 10 ;

//   map<string, BranchStmt> BranchStmts = 11 ;

//   map<string, CallExpr> CallExprs = 12 ;

//   map<string, CaseClause> CaseClauses = 13 ;

//   map<string, ChanDir> ChanDirs = 14 ;

//   map<string, ChanType> ChanTypes = 15 ;

//   map<string, CommClause> CommClauses = 16 ;

//   map<string, CommentGroup> CommentGroups = 17 ;

//   map<string, Comment> Comments = 18 ;

//   map<string, CompositeLit> CompositeLits = 19 ;

//   map<string, DeclStmt> DeclStmts = 20 ;

//   map<string, DeferStmt> DeferStmts = 21 ;

//   map<string, Ellipsis> Ellipsiss = 22 ;

//   map<string, EmptyStmt> EmptyStmts = 23 ;

//   map<string, ExprStmt> ExprStmts = 24 ;

//   map<string, FieldList> FieldLists = 25 ;

//   map<string, Field> Fields = 26 ;

//   map<string, File> Files = 27 ;

//   map<string, ForStmt> ForStmts = 28 ;

//   map<string, FuncDecl> FuncDecls = 29 ;

//   map<string, FuncLit> FuncLits = 30 ;

//   map<string, FuncType> FuncTypes = 31 ;

//   map<string, GenDecl> GenDecls = 32 ;

//   map<string, GoStmt> GoStmts = 33 ;

//   map<string, Ident> Idents = 34 ;

//   map<string, IfStmt> IfStmts = 35 ;

//   map<string, ImportSpec> ImportSpecs = 36 ;

//   map<string, IncDecStmt> IncDecStmts = 37 ;

//   map<string, IndexExpr> IndexExprs = 38 ;

//   map<string, InterfaceType> InterfaceTypes = 39 ;

//   map<string, IsExported> IsExporteds = 40 ;

//   map<string, KeyValueExpr> KeyValueExprs = 41 ;

//   map<string, LabeledStmt> LabeledStmts = 42 ;

//   map<string, MapType> MapTypes = 43 ;

//   map<string, NewIdent> NewIdents = 44 ;

//   map<string, Node> Nodes = 45 ;

//   map<string, Package> Packages = 46 ;

//   map<string, ParenExpr> ParenExprs = 47 ;

//   map<string, RangeStmt> RangeStmts = 48 ;

//   map<string, ReturnStmt> ReturnStmts = 49 ;

//   map<string, SelectStmt> SelectStmts = 50 ;

//   map<string, SelectorExpr> SelectorExprs = 51 ;

//   map<string, SendStmt> SendStmts = 52 ;

//   map<string, SliceExpr> SliceExprs = 53 ;

//   map<string, StarExpr> StarExprs = 54 ;

//   map<string, StructType> StructTypes = 55 ;

//   map<string, SwitchStmt> SwitchStmts = 56 ;

//   map<string, TypeAssertExpr> TypeAssertExprs = 57 ;

//   map<string, TypeSpec> TypeSpecs = 58 ;

//   map<string, TypeSwitchStmt> TypeSwitchStmts = 59 ;

//   map<string, UnaryExpr> UnaryExprs = 60 ;

//   map<string, ValueSpec> ValueSpecs = 61 ;

//   // interfaces
//   map<string, Spec> Specs = 62 ;

//   map<string, Decl> Decls = 63 ;

//   map<string, Expr> Exprs = 64 ;

//   map<string, Stmt> Stmts = 65 ;
// }

// A TypeAssertExpr node represents an expression followed by a
// type assertion.
message TypeAssertExpr {
  optional Foo2 X = 1 ;

  // expression
  optional Foo3 Lparen = 2 ;

  optional Foo2 Type = 3 ;

  // asserted type; nil means type switch X.(type)
  optional Foo3 Rparen = 4 ;
}

message TypeSpec {
  optional Foo2 Name = 1 ;

  optional Foo2 Type = 2 ;
}

// An TypeSwitchStmt node represents a type switch statement.
message TypeSwitchStmt {
  optional Foo2 Switch = 1 ;

  // position of "switch" keyword
  optional Foo2 Init = 2 ;

  // initialization statement; or nil
  optional Foo2 Assign = 3 ;

  // x := y.(type) or y.(type)
  optional Foo2 Body = 4 ;
}

// A UnaryExpr node represents a unary expression.
// Unary "*" expressions are represented via StarExpr nodes.
message UnaryExpr {
  optional Foo3 OpPos = 1 ;

  optional Foo3 Op = 2 ;

  // operator
  optional Foo2 X = 3 ;
}

message ValueSpec {
  repeated Ident Names = 1;

  optional Foo2 Type = 2 ;

  repeated Expr Values = 3 ;
}

