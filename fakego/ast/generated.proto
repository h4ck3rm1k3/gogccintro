/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = 'proto2';

package github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto;

//import "github.com/gogo/protobuf/gogoproto/gogo.proto";
//import "github.com/h4ck3rm1k3/gogccintro/fakego/ast";

// Package-wide variables from generator "generated".
//option (gogoproto.marshaler_all) = true;
// option (gogoproto.sizer_all) = true;
// option (gogoproto.goproto_stringer_all) = false;
// option (gogoproto.stringer_all) = true;
// option (gogoproto.unmarshaler_all) = true;
// option (gogoproto.goproto_unrecognized_all) = false;
// option (gogoproto.goproto_enum_prefix_all) = false;
// option (gogoproto.goproto_getters_all) = false;
option go_package = "astproto";

enum NodeType {
     ARRAYTYPE = 0; // ENUM BASE
     ASSIGNSTMT = 1; // ENUM BASE
     BADDECL = 2; // ENUM BASE
     BADEXPR = 3; // ENUM BASE
     BADSTMT = 4; // ENUM BASE
     BASICLIT = 5; // ENUM BASE
     BINARYEXPR = 6; // ENUM BASE
     BLOCKSTMT = 7; // ENUM BASE
     BRANCHSTMT = 8; // ENUM BASE
     CALLEXPR = 9; // ENUM BASE
    CASECLAUSE = 10; // ENUM BASE
    CHANDIR = 11; // ENUM BASE
    CHANTYPE = 12; // ENUM BASE
    COMMCLAUSE = 13; // ENUM BASE
    COMMENT = 14; // ENUM BASE
    COMPOSITELIT = 15; // ENUM BASE
    DECLSTMT = 16; // ENUM BASE
    DEFERSTMT = 17; // ENUM BASE
    ELLIPSIS = 18; // ENUM BASE
    EMPTYSTMT = 19; // ENUM BASE
    EXPRSTMT = 20; // ENUM BASE
    FIELD = 21; // ENUM BASE
    FIELDLIST = 22; // ENUM BASE
    FILE = 23; // ENUM BASE
    FORSTMT = 24; // ENUM BASE
    FUNCDECL = 25; // ENUM BASE
    FUNCLIT = 26; // ENUM BASE
    FUNCTYPE = 27; // ENUM BASE
    GENDECL = 28; // ENUM BASE
    GOSTMT = 29; // ENUM BASE
    IDENT = 30; // ENUM BASE
    IFSTMT = 31; // ENUM BASE
    IMPORTSPEC = 32; // ENUM BASE
    INCDECSTMT = 33; // ENUM BASE
    INDEXEXPR = 34; // ENUM BASE
    INTERFACETYPE = 35; // ENUM BASE
    ISEXPORTED = 36; // ENUM BASE
    KEYVALUEEXPR = 37; // ENUM BASE
    LABELEDSTMT = 38; // ENUM BASE
    MAPTYPE = 39; // ENUM BASE
    NEWIDENT = 40; // ENUM BASE
    PACKAGE = 41; // ENUM BASE
    PARENEXPR = 42; // ENUM BASE
    RANGESTMT = 43; // ENUM BASE
    RETURNSTMT = 44; // ENUM BASE
    SELECTSTMT = 45; // ENUM BASE
    SELECTOREXPR = 46; // ENUM BASE
    SENDSTMT = 47; // ENUM BASE
    SLICEEXPR = 48; // ENUM BASE
    SPEC = 49; // ENUM BASE
    STAREXPR = 50; // ENUM BASE
    STRUCTTYPE = 51; // ENUM BASE
    SWITCHSTMT = 52; // ENUM BASE
    TYPEASSERTEXPR = 53; // ENUM BASE
    TYPESPEC = 54; // ENUM BASE
    TYPESWITCHSTMT = 55; // ENUM BASE
    UNARYEXPR = 56; // ENUM BASE
    VALUESPEC = 57; // ENUM BASE
    COMMENTGROUP = 58; // ENUM BASE
    OBJECT = 59; // ENUM BASE

    DEFERRED = 60; // extras
    DEFERRED2 = 61; // extras
    FIELDDEFERRED = 62; // extras	
}

message ExprStmt {
	required Expr X=1; // expression	
}

message StarExpr {}
message DeclStmt {}
message BadDecl {}
message ChanDir {}
message ChanType {}
message Comment {
	required Foo3 Slash=1;
	required string	Text=2;
}
message ReturnStmt {}
message IsExported {}
message NewIdent {}
message Node {}



// An AssignStmt node represents an assignment or
// a short variable declaration.
message Expr {
	required NodeType type = 1;
optional BadExpr badexpr = 3; // Interface:Expr
optional BinaryExpr binaryexpr = 6; // Interface:Expr
optional CallExpr callexpr = 9; // Interface:Expr
optional ExprStmt exprstmt = 20; // Interface:Expr
optional IndexExpr indexexpr = 34; // Interface:Expr
optional KeyValueExpr keyvalueexpr = 37; // Interface:Expr
optional ParenExpr parenexpr = 42; // Interface:Expr
optional SelectorExpr selectorexpr = 46; // Interface:Expr
optional SliceExpr sliceexpr = 48; // Interface:Expr
optional StarExpr starexpr = 50; // Interface:Expr
optional TypeAssertExpr typeassertexpr = 53; // Interface:Expr
optional UnaryExpr unaryexpr = 56; // Interface:Expr

// look like we need to add these extra fields for expr
optional FuncType functype = 27; // Interface:BASE
optional Ident ident = 30; // Interface:BASE
optional InterfaceType interfacetype = 35; // Interface:BASE
optional StructType structtype = 51; // Interface:BASE
optional ArrayType arraytype = 61; // Interface:BASE
optional BasicLit basiclit = 5; // Interface:BASE
optional CompositeLit compositelit = 15; // Interface:BASE



optional BadDecl baddecl = 2; // Interface:BASE

optional BadStmt badstmt = 4; // Interface:BASE


optional BlockStmt blockstmt = 7; // Interface:BASE
optional BranchStmt branchstmt = 8; // Interface:BASE

optional CaseClause caseclause = 10; // Interface:BASE
optional ChanDir chandir = 11; // Interface:BASE
optional ChanType chantype = 12; // Interface:BASE
optional CommClause commclause = 13; // Interface:BASE
optional Comment comment = 14; // Interface:BASE

optional DeclStmt declstmt = 16; // Interface:BASE
optional DeferStmt deferstmt = 17; // Interface:BASE
optional Ellipsis ellipsis = 18; // Interface:BASE
optional EmptyStmt emptystmt = 19; // Interface:BASE

optional Field field = 21; // Interface:BASE
optional FieldList fieldlist = 22; // Interface:BASE
optional File file = 23; // Interface:BASE
optional ForStmt forstmt = 24; // Interface:BASE
optional FuncDecl funcdecl = 25; // Interface:BASE
optional FuncLit funclit = 26; // Interface:BASE

optional GenDecl gendecl = 28; // Interface:BASE
optional GoStmt gostmt = 29; // Interface:BASE

optional IfStmt ifstmt = 31; // Interface:BASE
optional ImportSpec importspec = 32; // Interface:BASE
optional IncDecStmt incdecstmt = 33; // Interface:BASE


optional IsExported isexported = 36; // Interface:BASE

optional LabeledStmt labeledstmt = 38; // Interface:BASE
optional MapType maptype = 39; // Interface:BASE
optional NewIdent newident = 40; // Interface:BASE
optional Package package = 41; // Interface:BASE

optional RangeStmt rangestmt = 43; // Interface:BASE
optional ReturnStmt returnstmt = 44; // Interface:BASE
optional SelectStmt selectstmt = 45; // Interface:BASE

optional SendStmt sendstmt = 47; // Interface:BASE

optional Spec spec = 49; // Interface:BASE


optional SwitchStmt switchstmt = 52; // Interface:BASE

optional TypeSpec typespec = 54; // Interface:BASE
optional TypeSwitchStmt typeswitchstmt = 55; // Interface:BASE

optional ValueSpec valuespec = 57; // Interface:BASE
optional CommentGroup commentgroup = 58; // Interface:BASE
optional AssignStmt assignstmt = 59; // Interface:BASE
optional Object object = 60; // Interface:BASE


optional Deferred deferred = 62; // Interface:BASE

}

message Stmt {
	required NodeType type = 1;

optional BadStmt badstmt = 4; // Interface:Stmt
optional BlockStmt blockstmt = 7; // Interface:Stmt
optional BranchStmt branchstmt = 8; // Interface:Stmt
optional DeclStmt declstmt = 16; // Interface:Stmt
optional DeferStmt deferstmt = 17; // Interface:Stmt
optional EmptyStmt emptystmt = 19; // Interface:Stmt
optional ExprStmt exprstmt = 20; // Interface:Stmt
optional ForStmt forstmt = 24; // Interface:Stmt
optional GoStmt gostmt = 29; // Interface:Stmt
optional IfStmt ifstmt = 31; // Interface:Stmt
optional IncDecStmt incdecstmt = 33; // Interface:Stmt
optional LabeledStmt labeledstmt = 38; // Interface:Stmt
optional RangeStmt rangestmt = 43; // Interface:Stmt
optional ReturnStmt returnstmt = 44; // Interface:Stmt
optional SelectStmt selectstmt = 45; // Interface:Stmt
optional SendStmt sendstmt = 47; // Interface:Stmt
optional SwitchStmt switchstmt = 52; // Interface:Stmt
optional TypeSwitchStmt typeswitchstmt = 55; // Interface:Stmt
optional AssignStmt assignstmt = 56; // Interface:Stmt
}

message Decl {
	required NodeType type = 1;
optional BadDecl baddecl = 2; // Interface:Decl
optional DeclStmt declstmt = 16; // Interface:Decl
optional FuncDecl funcdecl = 25; // Interface:Decl
optional GenDecl gendecl = 28; // Interface:Decl

}
message Spec {}
message ImportSpec {
	optional Ident Name=1;
	required BasicLit Path=2;
	optional Foo3 EndPos=3;
}
message CommentGroup {}


message  Foo3{
	 optional int64 tokenpos = 1; 
}

message  FieldDeferred{
	 optional string id = 1; 
}


message  Foo2{
	required NodeType type = 1;

optional BadDecl baddecl = 2; // Interface:BASE
optional BadExpr badexpr = 3; // Interface:BASE
optional BadStmt badstmt = 4; // Interface:BASE
optional BasicLit basiclit = 5; // Interface:BASE
optional BinaryExpr binaryexpr = 6; // Interface:BASE
optional BlockStmt blockstmt = 7; // Interface:BASE
optional BranchStmt branchstmt = 8; // Interface:BASE
optional CallExpr callexpr = 9; // Interface:BASE
optional CaseClause caseclause = 10; // Interface:BASE
optional ChanDir chandir = 11; // Interface:BASE
optional ChanType chantype = 12; // Interface:BASE
optional CommClause commclause = 13; // Interface:BASE
optional Comment comment = 14; // Interface:BASE
optional CompositeLit compositelit = 15; // Interface:BASE
optional DeclStmt declstmt = 16; // Interface:BASE
optional DeferStmt deferstmt = 17; // Interface:BASE
optional Ellipsis ellipsis = 18; // Interface:BASE
optional EmptyStmt emptystmt = 19; // Interface:BASE
optional ExprStmt exprstmt = 20; // Interface:BASE
optional Field field = 21; // Interface:BASE
optional FieldList fieldlist = 22; // Interface:BASE
optional File file = 23; // Interface:BASE
optional ForStmt forstmt = 24; // Interface:BASE
optional FuncDecl funcdecl = 25; // Interface:BASE
optional FuncLit funclit = 26; // Interface:BASE
optional FuncType functype = 27; // Interface:BASE
optional GenDecl gendecl = 28; // Interface:BASE
optional GoStmt gostmt = 29; // Interface:BASE
optional Ident ident = 30; // Interface:BASE
optional IfStmt ifstmt = 31; // Interface:BASE
optional ImportSpec importspec = 32; // Interface:BASE
optional IncDecStmt incdecstmt = 33; // Interface:BASE
optional IndexExpr indexexpr = 34; // Interface:BASE
optional InterfaceType interfacetype = 35; // Interface:BASE
optional IsExported isexported = 36; // Interface:BASE
optional KeyValueExpr keyvalueexpr = 37; // Interface:BASE
optional LabeledStmt labeledstmt = 38; // Interface:BASE
optional MapType maptype = 39; // Interface:BASE
optional NewIdent newident = 40; // Interface:BASE
optional Package package = 41; // Interface:BASE
optional ParenExpr parenexpr = 42; // Interface:BASE
optional RangeStmt rangestmt = 43; // Interface:BASE
optional ReturnStmt returnstmt = 44; // Interface:BASE
optional SelectStmt selectstmt = 45; // Interface:BASE
optional SelectorExpr selectorexpr = 46; // Interface:BASE
optional SendStmt sendstmt = 47; // Interface:BASE
optional SliceExpr sliceexpr = 48; // Interface:BASE
optional Spec spec = 49; // Interface:BASE
optional StarExpr starexpr = 50; // Interface:BASE
optional StructType structtype = 51; // Interface:BASE
optional SwitchStmt switchstmt = 52; // Interface:BASE
optional TypeAssertExpr typeassertexpr = 53; // Interface:BASE
optional TypeSpec typespec = 54; // Interface:BASE
optional TypeSwitchStmt typeswitchstmt = 55; // Interface:BASE
optional UnaryExpr unaryexpr = 56; // Interface:BASE
optional ValueSpec valuespec = 57; // Interface:BASE
optional CommentGroup commentgroup = 58; // Interface:BASE
optional AssignStmt assignstmt = 59; // Interface:BASE
optional Object object = 60; // Interface:BASE
optional ArrayType arraytype = 61; // Interface:BASE

optional Deferred deferred = 62; // Interface:BASE
optional FieldDeferred fielddeferred = 63; 

}

message AssignStmt {
  repeated Expr Lhs = 1 ;

  optional Foo3 TokPos = 2 ;

  // position of Tok
  optional Foo3 Tok = 3 ;

  // assignment token, DEFINE
  repeated Expr Rhs = 4 ;
}

message BadExpr {
  optional Foo2 From = 1 ;

  optional Foo2 To = 2 ;
}

// A BadStmt node is a placeholder for statements containing
// syntax errors for which no correct statement nodes can be
// created.
message BadStmt {
  optional Foo2 From = 1 ;

  optional Foo2 To = 2 ;
}

message BasicLit {
  optional Foo3 ValuePos = 1 ;

  optional string Kind = 2 ;

  optional string Value = 3 ;
}

// A BinaryExpr node represents a binary expression.
message BinaryExpr {
  optional Expr X = 1 ;

  // left operand
  optional Foo3 OpPos = 2 ;

  // position of Op
  optional Foo3 Op = 3 ;

  // operator
  optional Expr Y = 4 ;
}

message BlockStmt {
  optional Foo3 Lbrace = 1 ;

  repeated Stmt List = 2 ;

  optional Foo3 Rbrace = 3 ;
}

// A BranchStmt node represents a break, continue, goto,
// or fallthrough statement.
message BranchStmt {
  optional Foo3 TokPos = 1 ;

  optional Foo3 Tok = 2 ;

  // keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)
  optional Ident Label = 3;
}

// A CallExpr node represents an expression followed by an argument list.
message CallExpr {
  required Expr Fun = 1 ;

  // function expression
  optional Foo3 Lparen = 2 ;

  repeated Expr Args = 3 ;

  optional Foo3 Ellipsis = 4 ;

  optional Foo3 Rparen = 5 ;
}

// A CaseClause represents a case of an expression or type switch statement.
message CaseClause {
  optional Foo3 Case = 1 ;

  repeated Expr List = 2 ;

  // list of expressions or types; nil means default case
  optional Foo3 Colon = 3 ;

  repeated Stmt Body = 4 ;
}

// A CommClause node represents a case of a select statement.
message CommClause {
  optional Foo2 Case = 1 ;

  // position of "case" or "default" keyword
  required Stmt Comm = 2 ;

  // send or receive statement; nil means default case
  optional Foo2 Colon = 3 ;

  // position of ":"
  repeated Stmt Body = 4 ;
}

// A CompositeLit node represents a composite literal.
message CompositeLit {
  required Expr Type = 1 ;

  // literal type; or nil
  optional Foo3 Lbrace = 2 ;

  repeated Expr Elts = 3 ;

  // []list of composite elements; or nil
  optional Foo3 Rbrace = 4 ;
}

// A DeferStmt node represents a defer statement.
message DeferStmt {
  optional Foo3 Defer = 1 ;

  optional CallExpr Call = 2;
}

// deferred
message Deferred {
  optional string Id = 1 ;

  // Data  Foo2
  // Data  int64
   required NodeType type = 2;
}


// An Ellipsis node stands for the "..." type in a
// parameter list or the "..." length in an array type.
message Ellipsis {
  optional Foo3 Ellipsis = 1 ;

  // position of "..."
  optional Expr Elt = 2 ;
}

// An EmptyStmt node represents an empty statement.
// The "position" of the empty statement is the position
// of the immediately following (explicit or implicit) semicolon.
message EmptyStmt {
  optional Foo2 Semicolon = 1 ;

  // position of following ";"
  optional bool Implicit = 2 ;
}

message Field {
  repeated Ident Names = 1;

  required Expr Type = 2 ;

  optional BasicLit Tag = 3 ;

  optional CommentGroup Comment =4;
}

message FieldList {
  optional Foo3 Opening = 1 ;

  repeated Field List = 2;

  optional Foo3 Closing = 3 ;
}

message File {
  optional CommentGroup Doc  = 8;
  optional Foo3 Package = 1 ;

  optional Ident Name = 2 ;

  repeated Decl Decls = 3 ;

  optional Scope Scope = 4 ;

  repeated ImportSpec Imports = 5;

  repeated Ident Unresolved = 6;

  repeated CommentGroup Comments = 7;
}

// A ForStmt represents a for statement.
message ForStmt {
  optional Foo3 For = 1 ;

  // position of "for" keyword
  required Stmt Init = 2 ;

  // initialization statement; or nil
  required Expr Cond = 3 ;

  // condition; or nil
  required Stmt Post = 4 ;

  // post iteration statement; or nil
  optional BlockStmt Body = 5 ;
}

message FuncDecl {
  optional FieldList Recv = 1 ;
  optional Ident Name = 2 ;
  optional FuncType Type = 3 ;
  optional BlockStmt Body = 4 ;
  optional CommentGroup Doc = 5;	
}

// A FuncLit node represents a function literal.
message FuncLit {
  optional FuncType Type = 1;

  // function type
  optional BlockStmt Body = 2;
}

message FuncType {
  optional Foo3 Func = 1 ;

  optional Foo2 Params = 2 ;

  optional FieldList Results = 3;
}

message GenDecl {
  optional Foo3 TokPos = 1 ;

  optional Foo3 Tok = 2 ;

  optional Foo3 Lparen = 3 ;

  repeated Spec Specs = 4 ;

  optional Foo3 Rparen = 5 ;
}

// A GoStmt node represents a go statement.
message GoStmt {
  optional Foo2 Go = 1 ;

  // position of "go" keyword
  optional CallExpr Call = 2;
}

message Ident {
  optional Foo3 NamePos = 1 ;

  optional string Name = 2 ;

  optional Foo2 Obj = 3 ;
}

// An IfStmt node represents an if statement.
message IfStmt {
  optional Foo3 If = 1 ;

  required Stmt Init = 2 ;

  // initialization statement; or nil
  required Expr Cond = 3 ;

  // condition
  optional BlockStmt Body = 4 ;

  optional Stmt Else = 5 ;
}

// An IncDecStmt node represents an increment or decrement statement.
message IncDecStmt {
  optional Expr X = 1 ;

  optional Foo3 TokPos = 2 ;

  // position of Tok
  optional Foo3 Tok = 3 ;
}

// An IndexExpr node represents an expression followed by an index.
message IndexExpr {
  required Expr X = 1 ;

  // expression
  optional Foo3 Lbrack = 2 ;

  required Expr Index = 3 ;

  // index expression
  optional Foo3 Rbrack = 4 ;
}

message InterfaceType {
  optional Foo3 Interface = 1 ;

  optional FieldList Methods = 2;

  optional bool Incomplete = 3 ;
}

// A KeyValueExpr node represents (key : value) pairs
// in composite literals.
message KeyValueExpr {
  optional Expr Key = 1 ;

  optional Foo3 Colon = 2 ;

  // position of ":"
  optional Expr Value = 3 ;
}

// A LabeledStmt node represents a labeled statement.
message LabeledStmt {
  optional Ident Label = 1;

  optional Foo3 Colon = 2 ;

  // position of ":"
  required Stmt Stmt = 3 ;
}

message MapType {
  optional Foo3 Map = 1 ;

  optional Expr Key = 2 ;

  optional Expr Value = 3 ;
}

message Object {
  optional Deferred Deferred = 1 ;

  optional string Kind = 2 ;

  optional string Name = 3 ;

  optional Foo2 Decl = 4 ;

  optional Foo3 Data = 5 ;
}

message Package {
  optional string Name = 1 ;

  // package name
  optional Foo2 Scope = 2 ;

  // package scope across all files
  map<string, Object> Imports = 3 ;

  // map of package id -> package object
  map<string, File> Files = 4 ;
}

// A ParenFoo2 node represents a parenthesized expression.
message ParenExpr {
  required Foo3 Lparen = 1 ;

  required Expr X = 2 ;

  // parenthesized expression
  required Foo3 Rparen = 3 ;
}

// A RangeStmt represents a for statement with a range clause.
message RangeStmt {
  required Foo3 For = 1 ;

  required Expr Key = 2 ;

  required Expr Value = 3 ;

  // Key, Value may be nil
  required Foo3 TokPos = 4 ;

  required Foo3 Tok = 5 ;

  // ILLEGAL if Key == nil, ASSIGN, DEFINE
  required Expr X = 6 ;

  // Expr        // value to range over
  optional BlockStmt Body = 7 ;
}

message Scope {
  map<string, Object> Objects = 1 ;
}

// An SelectStmt node represents a select statement.
message SelectStmt {
  optional Foo2 Select = 1 ;

  // position of "select" keyword
  optional BlockStmt Body = 2 ;
}

message SelectorExpr {
  required Expr X = 1 ;

  optional Ident Sel = 2 ;
}

// A SendStmt node represents a send statement.
message SendStmt {
  required Expr Chan = 1 ;

  optional Foo2 Arrow = 2 ;

  required   Expr Value = 3 ;
}

// An SliceExpr node represents an expression followed by slice indices.
message SliceExpr {
  optional Expr X = 1 ;

  // expression
  optional Foo3 Lbrack = 2 ;

  optional Expr Low = 3 ;

  // begin of slice range; or nil
  optional Expr High = 4 ;

  // end of slice range; or nil
  optional Expr Max = 5 ;

  // maximum capacity of slice; or nil
  optional bool Slice3 = 6 ;

  // true if 3-index slice (2 colons present)
  optional Foo3 Rbrack = 7 ;
}

message StructType {
  optional Foo3 Struct = 1 ;

  optional FieldList Fields = 2;

  optional bool Incomplete = 3 ;
}

// A SwitchStmt node represents an expression switch statement.
message SwitchStmt {
  optional Foo3 Switch = 1 ;

  // position of "switch" keyword
  required Stmt Init = 2 ;

  // initialization statement; or nil
  required Expr Tag = 3 ;

  // tag expression; or nil
  optional BlockStmt Body = 4 ;
}

message ArrayType {
	required Foo3 Lbrack =1;
	required Expr Elt  =2;
}

// A TypeAssertExpr node represents an expression followed by a
// type assertion.
message TypeAssertExpr {
  required Expr X = 1 ;

  // expression
  optional Foo3 Lparen = 2 ;

  optional Expr Type = 3 ;

  // asserted type; nil means type switch X.(type)
  optional Foo3 Rparen = 4 ;
}

message TypeSpec {
  optional Ident Name = 1 ;
  required Expr Type = 2 ;
  optional CommentGroup Doc = 3;
  optional CommentGroup Comment = 4;
}

// An TypeSwitchStmt node represents a type switch statement.
message TypeSwitchStmt {
  optional Foo2 Switch = 1 ;

  // position of "switch" keyword
  required Stmt Init = 2 ;

  // initialization statement; or nil
  required Stmt Assign = 3 ;

  // x := y.(type) or y.(type)
  optional BlockStmt Body = 4 ;
}

// A UnaryExpr node represents a unary expression.
// Unary "*" expressions are represented via StarExpr nodes.
message UnaryExpr {
  optional Foo3 OpPos = 1 ;

  optional Foo3 Op = 2 ;

  // operator
  required Expr X = 3 ;
}

message ValueSpec {
  repeated Ident Names = 1;

  required Expr Type = 2 ;

  repeated Expr Values = 3 ;
}

