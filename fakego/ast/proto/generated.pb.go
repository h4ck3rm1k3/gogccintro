// Code generated by protoc-gen-go.
// source: generated.proto
// DO NOT EDIT!

/*
Package astproto is a generated protocol buffer package.

It is generated from these files:
	generated.proto

It has these top-level messages:
	ExprStmt
	StarExpr
	DeclStmt
	BadDecl
	ChanDir
	ChanType
	Comment
	ReturnStmt
	IsExported
	NewIdent
	Node
	Expr
	Stmt
	Decl
	Spec
	ImportSpec
	CommentGroup
	Foo3
	Foo2
	AssignStmt
	BadExpr
	BadStmt
	BasicLit
	BinaryExpr
	BlockStmt
	BranchStmt
	CallExpr
	CaseClause
	CommClause
	CompositeLit
	DeferStmt
	Deferred
	Ellipsis
	EmptyStmt
	Field
	FieldList
	File
	ForStmt
	FuncDecl
	FuncLit
	FuncType
	GenDecl
	GoStmt
	Ident
	IfStmt
	IncDecStmt
	IndexExpr
	InterfaceType
	KeyValueExpr
	LabeledStmt
	MapType
	Object
	Package
	ParenExpr
	RangeStmt
	Scope
	SelectStmt
	SelectorExpr
	SendStmt
	SliceExpr
	StructType
	SwitchStmt
	ArrayType
	TypeAssertExpr
	TypeSpec
	TypeSwitchStmt
	UnaryExpr
	ValueSpec
*/
package astproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type NodeType int32

const (
	NodeType_ARRAYTYPE      NodeType = 0
	NodeType_ASSIGNSTMT     NodeType = 1
	NodeType_BADDECL        NodeType = 2
	NodeType_BADEXPR        NodeType = 3
	NodeType_BADSTMT        NodeType = 4
	NodeType_BASICLIT       NodeType = 5
	NodeType_BINARYEXPR     NodeType = 6
	NodeType_BLOCKSTMT      NodeType = 7
	NodeType_BRANCHSTMT     NodeType = 8
	NodeType_CALLEXPR       NodeType = 9
	NodeType_CASECLAUSE     NodeType = 10
	NodeType_CHANDIR        NodeType = 11
	NodeType_CHANTYPE       NodeType = 12
	NodeType_COMMCLAUSE     NodeType = 13
	NodeType_COMMENT        NodeType = 14
	NodeType_COMPOSITELIT   NodeType = 15
	NodeType_DECLSTMT       NodeType = 16
	NodeType_DEFERSTMT      NodeType = 17
	NodeType_ELLIPSIS       NodeType = 18
	NodeType_EMPTYSTMT      NodeType = 19
	NodeType_EXPRSTMT       NodeType = 20
	NodeType_FIELD          NodeType = 21
	NodeType_FIELDLIST      NodeType = 22
	NodeType_FILE           NodeType = 23
	NodeType_FORSTMT        NodeType = 24
	NodeType_FUNCDECL       NodeType = 25
	NodeType_FUNCLIT        NodeType = 26
	NodeType_FUNCTYPE       NodeType = 27
	NodeType_GENDECL        NodeType = 28
	NodeType_GOSTMT         NodeType = 29
	NodeType_IDENT          NodeType = 30
	NodeType_IFSTMT         NodeType = 31
	NodeType_IMPORTSPEC     NodeType = 32
	NodeType_INCDECSTMT     NodeType = 33
	NodeType_INDEXEXPR      NodeType = 34
	NodeType_INTERFACETYPE  NodeType = 35
	NodeType_ISEXPORTED     NodeType = 36
	NodeType_KEYVALUEEXPR   NodeType = 37
	NodeType_LABELEDSTMT    NodeType = 38
	NodeType_MAPTYPE        NodeType = 39
	NodeType_NEWIDENT       NodeType = 40
	NodeType_PACKAGE        NodeType = 41
	NodeType_PARENEXPR      NodeType = 42
	NodeType_RANGESTMT      NodeType = 43
	NodeType_RETURNSTMT     NodeType = 44
	NodeType_SELECTSTMT     NodeType = 45
	NodeType_SELECTOREXPR   NodeType = 46
	NodeType_SENDSTMT       NodeType = 47
	NodeType_SLICEEXPR      NodeType = 48
	NodeType_SPEC           NodeType = 49
	NodeType_STAREXPR       NodeType = 50
	NodeType_STRUCTTYPE     NodeType = 51
	NodeType_SWITCHSTMT     NodeType = 52
	NodeType_TYPEASSERTEXPR NodeType = 53
	NodeType_TYPESPEC       NodeType = 54
	NodeType_TYPESWITCHSTMT NodeType = 55
	NodeType_UNARYEXPR      NodeType = 56
	NodeType_VALUESPEC      NodeType = 57
	NodeType_COMMENTGROUP   NodeType = 58
	NodeType_OBJECT         NodeType = 59
	NodeType_DEFERRED       NodeType = 60
	NodeType_DEFERRED2      NodeType = 61
)

var NodeType_name = map[int32]string{
	0:  "ARRAYTYPE",
	1:  "ASSIGNSTMT",
	2:  "BADDECL",
	3:  "BADEXPR",
	4:  "BADSTMT",
	5:  "BASICLIT",
	6:  "BINARYEXPR",
	7:  "BLOCKSTMT",
	8:  "BRANCHSTMT",
	9:  "CALLEXPR",
	10: "CASECLAUSE",
	11: "CHANDIR",
	12: "CHANTYPE",
	13: "COMMCLAUSE",
	14: "COMMENT",
	15: "COMPOSITELIT",
	16: "DECLSTMT",
	17: "DEFERSTMT",
	18: "ELLIPSIS",
	19: "EMPTYSTMT",
	20: "EXPRSTMT",
	21: "FIELD",
	22: "FIELDLIST",
	23: "FILE",
	24: "FORSTMT",
	25: "FUNCDECL",
	26: "FUNCLIT",
	27: "FUNCTYPE",
	28: "GENDECL",
	29: "GOSTMT",
	30: "IDENT",
	31: "IFSTMT",
	32: "IMPORTSPEC",
	33: "INCDECSTMT",
	34: "INDEXEXPR",
	35: "INTERFACETYPE",
	36: "ISEXPORTED",
	37: "KEYVALUEEXPR",
	38: "LABELEDSTMT",
	39: "MAPTYPE",
	40: "NEWIDENT",
	41: "PACKAGE",
	42: "PARENEXPR",
	43: "RANGESTMT",
	44: "RETURNSTMT",
	45: "SELECTSTMT",
	46: "SELECTOREXPR",
	47: "SENDSTMT",
	48: "SLICEEXPR",
	49: "SPEC",
	50: "STAREXPR",
	51: "STRUCTTYPE",
	52: "SWITCHSTMT",
	53: "TYPEASSERTEXPR",
	54: "TYPESPEC",
	55: "TYPESWITCHSTMT",
	56: "UNARYEXPR",
	57: "VALUESPEC",
	58: "COMMENTGROUP",
	59: "OBJECT",
	60: "DEFERRED",
	61: "DEFERRED2",
}
var NodeType_value = map[string]int32{
	"ARRAYTYPE":      0,
	"ASSIGNSTMT":     1,
	"BADDECL":        2,
	"BADEXPR":        3,
	"BADSTMT":        4,
	"BASICLIT":       5,
	"BINARYEXPR":     6,
	"BLOCKSTMT":      7,
	"BRANCHSTMT":     8,
	"CALLEXPR":       9,
	"CASECLAUSE":     10,
	"CHANDIR":        11,
	"CHANTYPE":       12,
	"COMMCLAUSE":     13,
	"COMMENT":        14,
	"COMPOSITELIT":   15,
	"DECLSTMT":       16,
	"DEFERSTMT":      17,
	"ELLIPSIS":       18,
	"EMPTYSTMT":      19,
	"EXPRSTMT":       20,
	"FIELD":          21,
	"FIELDLIST":      22,
	"FILE":           23,
	"FORSTMT":        24,
	"FUNCDECL":       25,
	"FUNCLIT":        26,
	"FUNCTYPE":       27,
	"GENDECL":        28,
	"GOSTMT":         29,
	"IDENT":          30,
	"IFSTMT":         31,
	"IMPORTSPEC":     32,
	"INCDECSTMT":     33,
	"INDEXEXPR":      34,
	"INTERFACETYPE":  35,
	"ISEXPORTED":     36,
	"KEYVALUEEXPR":   37,
	"LABELEDSTMT":    38,
	"MAPTYPE":        39,
	"NEWIDENT":       40,
	"PACKAGE":        41,
	"PARENEXPR":      42,
	"RANGESTMT":      43,
	"RETURNSTMT":     44,
	"SELECTSTMT":     45,
	"SELECTOREXPR":   46,
	"SENDSTMT":       47,
	"SLICEEXPR":      48,
	"SPEC":           49,
	"STAREXPR":       50,
	"STRUCTTYPE":     51,
	"SWITCHSTMT":     52,
	"TYPEASSERTEXPR": 53,
	"TYPESPEC":       54,
	"TYPESWITCHSTMT": 55,
	"UNARYEXPR":      56,
	"VALUESPEC":      57,
	"COMMENTGROUP":   58,
	"OBJECT":         59,
	"DEFERRED":       60,
	"DEFERRED2":      61,
}

func (x NodeType) Enum() *NodeType {
	p := new(NodeType)
	*p = x
	return p
}
func (x NodeType) String() string {
	return proto.EnumName(NodeType_name, int32(x))
}
func (x *NodeType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(NodeType_value, data, "NodeType")
	if err != nil {
		return err
	}
	*x = NodeType(value)
	return nil
}
func (NodeType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type ExprStmt struct {
	X                *Expr  `protobuf:"bytes,1,req,name=X,json=x" json:"X,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ExprStmt) Reset()                    { *m = ExprStmt{} }
func (m *ExprStmt) String() string            { return proto.CompactTextString(m) }
func (*ExprStmt) ProtoMessage()               {}
func (*ExprStmt) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ExprStmt) GetX() *Expr {
	if m != nil {
		return m.X
	}
	return nil
}

type StarExpr struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *StarExpr) Reset()                    { *m = StarExpr{} }
func (m *StarExpr) String() string            { return proto.CompactTextString(m) }
func (*StarExpr) ProtoMessage()               {}
func (*StarExpr) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type DeclStmt struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *DeclStmt) Reset()                    { *m = DeclStmt{} }
func (m *DeclStmt) String() string            { return proto.CompactTextString(m) }
func (*DeclStmt) ProtoMessage()               {}
func (*DeclStmt) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type BadDecl struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *BadDecl) Reset()                    { *m = BadDecl{} }
func (m *BadDecl) String() string            { return proto.CompactTextString(m) }
func (*BadDecl) ProtoMessage()               {}
func (*BadDecl) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type ChanDir struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *ChanDir) Reset()                    { *m = ChanDir{} }
func (m *ChanDir) String() string            { return proto.CompactTextString(m) }
func (*ChanDir) ProtoMessage()               {}
func (*ChanDir) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type ChanType struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *ChanType) Reset()                    { *m = ChanType{} }
func (m *ChanType) String() string            { return proto.CompactTextString(m) }
func (*ChanType) ProtoMessage()               {}
func (*ChanType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type Comment struct {
	Slash            *Foo3   `protobuf:"bytes,1,req,name=Slash,json=slash" json:"Slash,omitempty"`
	Text             *string `protobuf:"bytes,2,req,name=Text,json=text" json:"Text,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Comment) Reset()                    { *m = Comment{} }
func (m *Comment) String() string            { return proto.CompactTextString(m) }
func (*Comment) ProtoMessage()               {}
func (*Comment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Comment) GetSlash() *Foo3 {
	if m != nil {
		return m.Slash
	}
	return nil
}

func (m *Comment) GetText() string {
	if m != nil && m.Text != nil {
		return *m.Text
	}
	return ""
}

type ReturnStmt struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *ReturnStmt) Reset()                    { *m = ReturnStmt{} }
func (m *ReturnStmt) String() string            { return proto.CompactTextString(m) }
func (*ReturnStmt) ProtoMessage()               {}
func (*ReturnStmt) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type IsExported struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *IsExported) Reset()                    { *m = IsExported{} }
func (m *IsExported) String() string            { return proto.CompactTextString(m) }
func (*IsExported) ProtoMessage()               {}
func (*IsExported) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type NewIdent struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *NewIdent) Reset()                    { *m = NewIdent{} }
func (m *NewIdent) String() string            { return proto.CompactTextString(m) }
func (*NewIdent) ProtoMessage()               {}
func (*NewIdent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type Node struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

// An AssignStmt node represents an assignment or
// a short variable declaration.
type Expr struct {
	Type           *NodeType       `protobuf:"varint,1,req,name=type,enum=github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.NodeType" json:"type,omitempty"`
	Badexpr        *BadExpr        `protobuf:"bytes,3,opt,name=badexpr" json:"badexpr,omitempty"`
	Binaryexpr     *BinaryExpr     `protobuf:"bytes,6,opt,name=binaryexpr" json:"binaryexpr,omitempty"`
	Callexpr       *CallExpr       `protobuf:"bytes,9,opt,name=callexpr" json:"callexpr,omitempty"`
	Exprstmt       *ExprStmt       `protobuf:"bytes,20,opt,name=exprstmt" json:"exprstmt,omitempty"`
	Indexexpr      *IndexExpr      `protobuf:"bytes,34,opt,name=indexexpr" json:"indexexpr,omitempty"`
	Keyvalueexpr   *KeyValueExpr   `protobuf:"bytes,37,opt,name=keyvalueexpr" json:"keyvalueexpr,omitempty"`
	Parenexpr      *ParenExpr      `protobuf:"bytes,42,opt,name=parenexpr" json:"parenexpr,omitempty"`
	Selectorexpr   *SelectorExpr   `protobuf:"bytes,46,opt,name=selectorexpr" json:"selectorexpr,omitempty"`
	Sliceexpr      *SliceExpr      `protobuf:"bytes,48,opt,name=sliceexpr" json:"sliceexpr,omitempty"`
	Starexpr       *StarExpr       `protobuf:"bytes,50,opt,name=starexpr" json:"starexpr,omitempty"`
	Typeassertexpr *TypeAssertExpr `protobuf:"bytes,53,opt,name=typeassertexpr" json:"typeassertexpr,omitempty"`
	Unaryexpr      *UnaryExpr      `protobuf:"bytes,56,opt,name=unaryexpr" json:"unaryexpr,omitempty"`
	// look like we need to add these extra fields for expr
	Functype         *FuncType       `protobuf:"bytes,27,opt,name=functype" json:"functype,omitempty"`
	Ident            *Ident          `protobuf:"bytes,30,opt,name=ident" json:"ident,omitempty"`
	Interfacetype    *InterfaceType  `protobuf:"bytes,35,opt,name=interfacetype" json:"interfacetype,omitempty"`
	Structtype       *StructType     `protobuf:"bytes,51,opt,name=structtype" json:"structtype,omitempty"`
	Arraytype        *ArrayType      `protobuf:"bytes,61,opt,name=arraytype" json:"arraytype,omitempty"`
	Basiclit         *BasicLit       `protobuf:"bytes,5,opt,name=basiclit" json:"basiclit,omitempty"`
	Compositelit     *CompositeLit   `protobuf:"bytes,15,opt,name=compositelit" json:"compositelit,omitempty"`
	Baddecl          *BadDecl        `protobuf:"bytes,2,opt,name=baddecl" json:"baddecl,omitempty"`
	Badstmt          *BadStmt        `protobuf:"bytes,4,opt,name=badstmt" json:"badstmt,omitempty"`
	Blockstmt        *BlockStmt      `protobuf:"bytes,7,opt,name=blockstmt" json:"blockstmt,omitempty"`
	Branchstmt       *BranchStmt     `protobuf:"bytes,8,opt,name=branchstmt" json:"branchstmt,omitempty"`
	Caseclause       *CaseClause     `protobuf:"bytes,10,opt,name=caseclause" json:"caseclause,omitempty"`
	Chandir          *ChanDir        `protobuf:"bytes,11,opt,name=chandir" json:"chandir,omitempty"`
	Chantype         *ChanType       `protobuf:"bytes,12,opt,name=chantype" json:"chantype,omitempty"`
	Commclause       *CommClause     `protobuf:"bytes,13,opt,name=commclause" json:"commclause,omitempty"`
	Comment          *Comment        `protobuf:"bytes,14,opt,name=comment" json:"comment,omitempty"`
	Declstmt         *DeclStmt       `protobuf:"bytes,16,opt,name=declstmt" json:"declstmt,omitempty"`
	Deferstmt        *DeferStmt      `protobuf:"bytes,17,opt,name=deferstmt" json:"deferstmt,omitempty"`
	Ellipsis         *Ellipsis       `protobuf:"bytes,18,opt,name=ellipsis" json:"ellipsis,omitempty"`
	Emptystmt        *EmptyStmt      `protobuf:"bytes,19,opt,name=emptystmt" json:"emptystmt,omitempty"`
	Field            *Field          `protobuf:"bytes,21,opt,name=field" json:"field,omitempty"`
	Fieldlist        *FieldList      `protobuf:"bytes,22,opt,name=fieldlist" json:"fieldlist,omitempty"`
	File             *File           `protobuf:"bytes,23,opt,name=file" json:"file,omitempty"`
	Forstmt          *ForStmt        `protobuf:"bytes,24,opt,name=forstmt" json:"forstmt,omitempty"`
	Funcdecl         *FuncDecl       `protobuf:"bytes,25,opt,name=funcdecl" json:"funcdecl,omitempty"`
	Funclit          *FuncLit        `protobuf:"bytes,26,opt,name=funclit" json:"funclit,omitempty"`
	Gendecl          *GenDecl        `protobuf:"bytes,28,opt,name=gendecl" json:"gendecl,omitempty"`
	Gostmt           *GoStmt         `protobuf:"bytes,29,opt,name=gostmt" json:"gostmt,omitempty"`
	Ifstmt           *IfStmt         `protobuf:"bytes,31,opt,name=ifstmt" json:"ifstmt,omitempty"`
	Importspec       *ImportSpec     `protobuf:"bytes,32,opt,name=importspec" json:"importspec,omitempty"`
	Incdecstmt       *IncDecStmt     `protobuf:"bytes,33,opt,name=incdecstmt" json:"incdecstmt,omitempty"`
	Isexported       *IsExported     `protobuf:"bytes,36,opt,name=isexported" json:"isexported,omitempty"`
	Labeledstmt      *LabeledStmt    `protobuf:"bytes,38,opt,name=labeledstmt" json:"labeledstmt,omitempty"`
	Maptype          *MapType        `protobuf:"bytes,39,opt,name=maptype" json:"maptype,omitempty"`
	Newident         *NewIdent       `protobuf:"bytes,40,opt,name=newident" json:"newident,omitempty"`
	Package          *Package        `protobuf:"bytes,41,opt,name=package" json:"package,omitempty"`
	Rangestmt        *RangeStmt      `protobuf:"bytes,43,opt,name=rangestmt" json:"rangestmt,omitempty"`
	Returnstmt       *ReturnStmt     `protobuf:"bytes,44,opt,name=returnstmt" json:"returnstmt,omitempty"`
	Selectstmt       *SelectStmt     `protobuf:"bytes,45,opt,name=selectstmt" json:"selectstmt,omitempty"`
	Sendstmt         *SendStmt       `protobuf:"bytes,47,opt,name=sendstmt" json:"sendstmt,omitempty"`
	Spec             *Spec           `protobuf:"bytes,49,opt,name=spec" json:"spec,omitempty"`
	Switchstmt       *SwitchStmt     `protobuf:"bytes,52,opt,name=switchstmt" json:"switchstmt,omitempty"`
	Typespec         *TypeSpec       `protobuf:"bytes,54,opt,name=typespec" json:"typespec,omitempty"`
	Typeswitchstmt   *TypeSwitchStmt `protobuf:"bytes,55,opt,name=typeswitchstmt" json:"typeswitchstmt,omitempty"`
	Valuespec        *ValueSpec      `protobuf:"bytes,57,opt,name=valuespec" json:"valuespec,omitempty"`
	Commentgroup     *CommentGroup   `protobuf:"bytes,58,opt,name=commentgroup" json:"commentgroup,omitempty"`
	Assignstmt       *AssignStmt     `protobuf:"bytes,59,opt,name=assignstmt" json:"assignstmt,omitempty"`
	Object           *Object         `protobuf:"bytes,60,opt,name=object" json:"object,omitempty"`
	Deferred         *Deferred       `protobuf:"bytes,62,opt,name=deferred" json:"deferred,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *Expr) Reset()                    { *m = Expr{} }
func (m *Expr) String() string            { return proto.CompactTextString(m) }
func (*Expr) ProtoMessage()               {}
func (*Expr) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Expr) GetType() NodeType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return NodeType_ARRAYTYPE
}

func (m *Expr) GetBadexpr() *BadExpr {
	if m != nil {
		return m.Badexpr
	}
	return nil
}

func (m *Expr) GetBinaryexpr() *BinaryExpr {
	if m != nil {
		return m.Binaryexpr
	}
	return nil
}

func (m *Expr) GetCallexpr() *CallExpr {
	if m != nil {
		return m.Callexpr
	}
	return nil
}

func (m *Expr) GetExprstmt() *ExprStmt {
	if m != nil {
		return m.Exprstmt
	}
	return nil
}

func (m *Expr) GetIndexexpr() *IndexExpr {
	if m != nil {
		return m.Indexexpr
	}
	return nil
}

func (m *Expr) GetKeyvalueexpr() *KeyValueExpr {
	if m != nil {
		return m.Keyvalueexpr
	}
	return nil
}

func (m *Expr) GetParenexpr() *ParenExpr {
	if m != nil {
		return m.Parenexpr
	}
	return nil
}

func (m *Expr) GetSelectorexpr() *SelectorExpr {
	if m != nil {
		return m.Selectorexpr
	}
	return nil
}

func (m *Expr) GetSliceexpr() *SliceExpr {
	if m != nil {
		return m.Sliceexpr
	}
	return nil
}

func (m *Expr) GetStarexpr() *StarExpr {
	if m != nil {
		return m.Starexpr
	}
	return nil
}

func (m *Expr) GetTypeassertexpr() *TypeAssertExpr {
	if m != nil {
		return m.Typeassertexpr
	}
	return nil
}

func (m *Expr) GetUnaryexpr() *UnaryExpr {
	if m != nil {
		return m.Unaryexpr
	}
	return nil
}

func (m *Expr) GetFunctype() *FuncType {
	if m != nil {
		return m.Functype
	}
	return nil
}

func (m *Expr) GetIdent() *Ident {
	if m != nil {
		return m.Ident
	}
	return nil
}

func (m *Expr) GetInterfacetype() *InterfaceType {
	if m != nil {
		return m.Interfacetype
	}
	return nil
}

func (m *Expr) GetStructtype() *StructType {
	if m != nil {
		return m.Structtype
	}
	return nil
}

func (m *Expr) GetArraytype() *ArrayType {
	if m != nil {
		return m.Arraytype
	}
	return nil
}

func (m *Expr) GetBasiclit() *BasicLit {
	if m != nil {
		return m.Basiclit
	}
	return nil
}

func (m *Expr) GetCompositelit() *CompositeLit {
	if m != nil {
		return m.Compositelit
	}
	return nil
}

func (m *Expr) GetBaddecl() *BadDecl {
	if m != nil {
		return m.Baddecl
	}
	return nil
}

func (m *Expr) GetBadstmt() *BadStmt {
	if m != nil {
		return m.Badstmt
	}
	return nil
}

func (m *Expr) GetBlockstmt() *BlockStmt {
	if m != nil {
		return m.Blockstmt
	}
	return nil
}

func (m *Expr) GetBranchstmt() *BranchStmt {
	if m != nil {
		return m.Branchstmt
	}
	return nil
}

func (m *Expr) GetCaseclause() *CaseClause {
	if m != nil {
		return m.Caseclause
	}
	return nil
}

func (m *Expr) GetChandir() *ChanDir {
	if m != nil {
		return m.Chandir
	}
	return nil
}

func (m *Expr) GetChantype() *ChanType {
	if m != nil {
		return m.Chantype
	}
	return nil
}

func (m *Expr) GetCommclause() *CommClause {
	if m != nil {
		return m.Commclause
	}
	return nil
}

func (m *Expr) GetComment() *Comment {
	if m != nil {
		return m.Comment
	}
	return nil
}

func (m *Expr) GetDeclstmt() *DeclStmt {
	if m != nil {
		return m.Declstmt
	}
	return nil
}

func (m *Expr) GetDeferstmt() *DeferStmt {
	if m != nil {
		return m.Deferstmt
	}
	return nil
}

func (m *Expr) GetEllipsis() *Ellipsis {
	if m != nil {
		return m.Ellipsis
	}
	return nil
}

func (m *Expr) GetEmptystmt() *EmptyStmt {
	if m != nil {
		return m.Emptystmt
	}
	return nil
}

func (m *Expr) GetField() *Field {
	if m != nil {
		return m.Field
	}
	return nil
}

func (m *Expr) GetFieldlist() *FieldList {
	if m != nil {
		return m.Fieldlist
	}
	return nil
}

func (m *Expr) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *Expr) GetForstmt() *ForStmt {
	if m != nil {
		return m.Forstmt
	}
	return nil
}

func (m *Expr) GetFuncdecl() *FuncDecl {
	if m != nil {
		return m.Funcdecl
	}
	return nil
}

func (m *Expr) GetFunclit() *FuncLit {
	if m != nil {
		return m.Funclit
	}
	return nil
}

func (m *Expr) GetGendecl() *GenDecl {
	if m != nil {
		return m.Gendecl
	}
	return nil
}

func (m *Expr) GetGostmt() *GoStmt {
	if m != nil {
		return m.Gostmt
	}
	return nil
}

func (m *Expr) GetIfstmt() *IfStmt {
	if m != nil {
		return m.Ifstmt
	}
	return nil
}

func (m *Expr) GetImportspec() *ImportSpec {
	if m != nil {
		return m.Importspec
	}
	return nil
}

func (m *Expr) GetIncdecstmt() *IncDecStmt {
	if m != nil {
		return m.Incdecstmt
	}
	return nil
}

func (m *Expr) GetIsexported() *IsExported {
	if m != nil {
		return m.Isexported
	}
	return nil
}

func (m *Expr) GetLabeledstmt() *LabeledStmt {
	if m != nil {
		return m.Labeledstmt
	}
	return nil
}

func (m *Expr) GetMaptype() *MapType {
	if m != nil {
		return m.Maptype
	}
	return nil
}

func (m *Expr) GetNewident() *NewIdent {
	if m != nil {
		return m.Newident
	}
	return nil
}

func (m *Expr) GetPackage() *Package {
	if m != nil {
		return m.Package
	}
	return nil
}

func (m *Expr) GetRangestmt() *RangeStmt {
	if m != nil {
		return m.Rangestmt
	}
	return nil
}

func (m *Expr) GetReturnstmt() *ReturnStmt {
	if m != nil {
		return m.Returnstmt
	}
	return nil
}

func (m *Expr) GetSelectstmt() *SelectStmt {
	if m != nil {
		return m.Selectstmt
	}
	return nil
}

func (m *Expr) GetSendstmt() *SendStmt {
	if m != nil {
		return m.Sendstmt
	}
	return nil
}

func (m *Expr) GetSpec() *Spec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Expr) GetSwitchstmt() *SwitchStmt {
	if m != nil {
		return m.Switchstmt
	}
	return nil
}

func (m *Expr) GetTypespec() *TypeSpec {
	if m != nil {
		return m.Typespec
	}
	return nil
}

func (m *Expr) GetTypeswitchstmt() *TypeSwitchStmt {
	if m != nil {
		return m.Typeswitchstmt
	}
	return nil
}

func (m *Expr) GetValuespec() *ValueSpec {
	if m != nil {
		return m.Valuespec
	}
	return nil
}

func (m *Expr) GetCommentgroup() *CommentGroup {
	if m != nil {
		return m.Commentgroup
	}
	return nil
}

func (m *Expr) GetAssignstmt() *AssignStmt {
	if m != nil {
		return m.Assignstmt
	}
	return nil
}

func (m *Expr) GetObject() *Object {
	if m != nil {
		return m.Object
	}
	return nil
}

func (m *Expr) GetDeferred() *Deferred {
	if m != nil {
		return m.Deferred
	}
	return nil
}

type Stmt struct {
	Type             *NodeType       `protobuf:"varint,1,req,name=type,enum=github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.NodeType" json:"type,omitempty"`
	Badstmt          *BadStmt        `protobuf:"bytes,4,opt,name=badstmt" json:"badstmt,omitempty"`
	Blockstmt        *BlockStmt      `protobuf:"bytes,7,opt,name=blockstmt" json:"blockstmt,omitempty"`
	Branchstmt       *BranchStmt     `protobuf:"bytes,8,opt,name=branchstmt" json:"branchstmt,omitempty"`
	Declstmt         *DeclStmt       `protobuf:"bytes,16,opt,name=declstmt" json:"declstmt,omitempty"`
	Deferstmt        *DeferStmt      `protobuf:"bytes,17,opt,name=deferstmt" json:"deferstmt,omitempty"`
	Emptystmt        *EmptyStmt      `protobuf:"bytes,19,opt,name=emptystmt" json:"emptystmt,omitempty"`
	Exprstmt         *ExprStmt       `protobuf:"bytes,20,opt,name=exprstmt" json:"exprstmt,omitempty"`
	Forstmt          *ForStmt        `protobuf:"bytes,24,opt,name=forstmt" json:"forstmt,omitempty"`
	Gostmt           *GoStmt         `protobuf:"bytes,29,opt,name=gostmt" json:"gostmt,omitempty"`
	Ifstmt           *IfStmt         `protobuf:"bytes,31,opt,name=ifstmt" json:"ifstmt,omitempty"`
	Incdecstmt       *IncDecStmt     `protobuf:"bytes,33,opt,name=incdecstmt" json:"incdecstmt,omitempty"`
	Labeledstmt      *LabeledStmt    `protobuf:"bytes,38,opt,name=labeledstmt" json:"labeledstmt,omitempty"`
	Rangestmt        *RangeStmt      `protobuf:"bytes,43,opt,name=rangestmt" json:"rangestmt,omitempty"`
	Returnstmt       *ReturnStmt     `protobuf:"bytes,44,opt,name=returnstmt" json:"returnstmt,omitempty"`
	Selectstmt       *SelectStmt     `protobuf:"bytes,45,opt,name=selectstmt" json:"selectstmt,omitempty"`
	Sendstmt         *SendStmt       `protobuf:"bytes,47,opt,name=sendstmt" json:"sendstmt,omitempty"`
	Switchstmt       *SwitchStmt     `protobuf:"bytes,52,opt,name=switchstmt" json:"switchstmt,omitempty"`
	Typeswitchstmt   *TypeSwitchStmt `protobuf:"bytes,55,opt,name=typeswitchstmt" json:"typeswitchstmt,omitempty"`
	Assignstmt       *AssignStmt     `protobuf:"bytes,56,opt,name=assignstmt" json:"assignstmt,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *Stmt) Reset()                    { *m = Stmt{} }
func (m *Stmt) String() string            { return proto.CompactTextString(m) }
func (*Stmt) ProtoMessage()               {}
func (*Stmt) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Stmt) GetType() NodeType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return NodeType_ARRAYTYPE
}

func (m *Stmt) GetBadstmt() *BadStmt {
	if m != nil {
		return m.Badstmt
	}
	return nil
}

func (m *Stmt) GetBlockstmt() *BlockStmt {
	if m != nil {
		return m.Blockstmt
	}
	return nil
}

func (m *Stmt) GetBranchstmt() *BranchStmt {
	if m != nil {
		return m.Branchstmt
	}
	return nil
}

func (m *Stmt) GetDeclstmt() *DeclStmt {
	if m != nil {
		return m.Declstmt
	}
	return nil
}

func (m *Stmt) GetDeferstmt() *DeferStmt {
	if m != nil {
		return m.Deferstmt
	}
	return nil
}

func (m *Stmt) GetEmptystmt() *EmptyStmt {
	if m != nil {
		return m.Emptystmt
	}
	return nil
}

func (m *Stmt) GetExprstmt() *ExprStmt {
	if m != nil {
		return m.Exprstmt
	}
	return nil
}

func (m *Stmt) GetForstmt() *ForStmt {
	if m != nil {
		return m.Forstmt
	}
	return nil
}

func (m *Stmt) GetGostmt() *GoStmt {
	if m != nil {
		return m.Gostmt
	}
	return nil
}

func (m *Stmt) GetIfstmt() *IfStmt {
	if m != nil {
		return m.Ifstmt
	}
	return nil
}

func (m *Stmt) GetIncdecstmt() *IncDecStmt {
	if m != nil {
		return m.Incdecstmt
	}
	return nil
}

func (m *Stmt) GetLabeledstmt() *LabeledStmt {
	if m != nil {
		return m.Labeledstmt
	}
	return nil
}

func (m *Stmt) GetRangestmt() *RangeStmt {
	if m != nil {
		return m.Rangestmt
	}
	return nil
}

func (m *Stmt) GetReturnstmt() *ReturnStmt {
	if m != nil {
		return m.Returnstmt
	}
	return nil
}

func (m *Stmt) GetSelectstmt() *SelectStmt {
	if m != nil {
		return m.Selectstmt
	}
	return nil
}

func (m *Stmt) GetSendstmt() *SendStmt {
	if m != nil {
		return m.Sendstmt
	}
	return nil
}

func (m *Stmt) GetSwitchstmt() *SwitchStmt {
	if m != nil {
		return m.Switchstmt
	}
	return nil
}

func (m *Stmt) GetTypeswitchstmt() *TypeSwitchStmt {
	if m != nil {
		return m.Typeswitchstmt
	}
	return nil
}

func (m *Stmt) GetAssignstmt() *AssignStmt {
	if m != nil {
		return m.Assignstmt
	}
	return nil
}

type Decl struct {
	Type             *NodeType `protobuf:"varint,1,req,name=type,enum=github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.NodeType" json:"type,omitempty"`
	Baddecl          *BadDecl  `protobuf:"bytes,2,opt,name=baddecl" json:"baddecl,omitempty"`
	Declstmt         *DeclStmt `protobuf:"bytes,16,opt,name=declstmt" json:"declstmt,omitempty"`
	Funcdecl         *FuncDecl `protobuf:"bytes,25,opt,name=funcdecl" json:"funcdecl,omitempty"`
	Gendecl          *GenDecl  `protobuf:"bytes,28,opt,name=gendecl" json:"gendecl,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *Decl) Reset()                    { *m = Decl{} }
func (m *Decl) String() string            { return proto.CompactTextString(m) }
func (*Decl) ProtoMessage()               {}
func (*Decl) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *Decl) GetType() NodeType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return NodeType_ARRAYTYPE
}

func (m *Decl) GetBaddecl() *BadDecl {
	if m != nil {
		return m.Baddecl
	}
	return nil
}

func (m *Decl) GetDeclstmt() *DeclStmt {
	if m != nil {
		return m.Declstmt
	}
	return nil
}

func (m *Decl) GetFuncdecl() *FuncDecl {
	if m != nil {
		return m.Funcdecl
	}
	return nil
}

func (m *Decl) GetGendecl() *GenDecl {
	if m != nil {
		return m.Gendecl
	}
	return nil
}

type Spec struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *Spec) Reset()                    { *m = Spec{} }
func (m *Spec) String() string            { return proto.CompactTextString(m) }
func (*Spec) ProtoMessage()               {}
func (*Spec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

type ImportSpec struct {
	Name             *Ident    `protobuf:"bytes,1,opt,name=Name,json=name" json:"Name,omitempty"`
	Path             *BasicLit `protobuf:"bytes,2,req,name=Path,json=path" json:"Path,omitempty"`
	EndPos           *Foo3     `protobuf:"bytes,3,opt,name=EndPos,json=endPos" json:"EndPos,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *ImportSpec) Reset()                    { *m = ImportSpec{} }
func (m *ImportSpec) String() string            { return proto.CompactTextString(m) }
func (*ImportSpec) ProtoMessage()               {}
func (*ImportSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *ImportSpec) GetName() *Ident {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *ImportSpec) GetPath() *BasicLit {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *ImportSpec) GetEndPos() *Foo3 {
	if m != nil {
		return m.EndPos
	}
	return nil
}

type CommentGroup struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *CommentGroup) Reset()                    { *m = CommentGroup{} }
func (m *CommentGroup) String() string            { return proto.CompactTextString(m) }
func (*CommentGroup) ProtoMessage()               {}
func (*CommentGroup) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

type Foo3 struct {
	Tokenpos         *int64 `protobuf:"varint,1,opt,name=tokenpos" json:"tokenpos,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Foo3) Reset()                    { *m = Foo3{} }
func (m *Foo3) String() string            { return proto.CompactTextString(m) }
func (*Foo3) ProtoMessage()               {}
func (*Foo3) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *Foo3) GetTokenpos() int64 {
	if m != nil && m.Tokenpos != nil {
		return *m.Tokenpos
	}
	return 0
}

type Foo2 struct {
	Type             *NodeType       `protobuf:"varint,1,req,name=type,enum=github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.NodeType" json:"type,omitempty"`
	Baddecl          *BadDecl        `protobuf:"bytes,2,opt,name=baddecl" json:"baddecl,omitempty"`
	Badexpr          *BadExpr        `protobuf:"bytes,3,opt,name=badexpr" json:"badexpr,omitempty"`
	Badstmt          *BadStmt        `protobuf:"bytes,4,opt,name=badstmt" json:"badstmt,omitempty"`
	Basiclit         *BasicLit       `protobuf:"bytes,5,opt,name=basiclit" json:"basiclit,omitempty"`
	Binaryexpr       *BinaryExpr     `protobuf:"bytes,6,opt,name=binaryexpr" json:"binaryexpr,omitempty"`
	Blockstmt        *BlockStmt      `protobuf:"bytes,7,opt,name=blockstmt" json:"blockstmt,omitempty"`
	Branchstmt       *BranchStmt     `protobuf:"bytes,8,opt,name=branchstmt" json:"branchstmt,omitempty"`
	Callexpr         *CallExpr       `protobuf:"bytes,9,opt,name=callexpr" json:"callexpr,omitempty"`
	Caseclause       *CaseClause     `protobuf:"bytes,10,opt,name=caseclause" json:"caseclause,omitempty"`
	Chandir          *ChanDir        `protobuf:"bytes,11,opt,name=chandir" json:"chandir,omitempty"`
	Chantype         *ChanType       `protobuf:"bytes,12,opt,name=chantype" json:"chantype,omitempty"`
	Commclause       *CommClause     `protobuf:"bytes,13,opt,name=commclause" json:"commclause,omitempty"`
	Comment          *Comment        `protobuf:"bytes,14,opt,name=comment" json:"comment,omitempty"`
	Compositelit     *CompositeLit   `protobuf:"bytes,15,opt,name=compositelit" json:"compositelit,omitempty"`
	Declstmt         *DeclStmt       `protobuf:"bytes,16,opt,name=declstmt" json:"declstmt,omitempty"`
	Deferstmt        *DeferStmt      `protobuf:"bytes,17,opt,name=deferstmt" json:"deferstmt,omitempty"`
	Ellipsis         *Ellipsis       `protobuf:"bytes,18,opt,name=ellipsis" json:"ellipsis,omitempty"`
	Emptystmt        *EmptyStmt      `protobuf:"bytes,19,opt,name=emptystmt" json:"emptystmt,omitempty"`
	Exprstmt         *ExprStmt       `protobuf:"bytes,20,opt,name=exprstmt" json:"exprstmt,omitempty"`
	Field            *Field          `protobuf:"bytes,21,opt,name=field" json:"field,omitempty"`
	Fieldlist        *FieldList      `protobuf:"bytes,22,opt,name=fieldlist" json:"fieldlist,omitempty"`
	File             *File           `protobuf:"bytes,23,opt,name=file" json:"file,omitempty"`
	Forstmt          *ForStmt        `protobuf:"bytes,24,opt,name=forstmt" json:"forstmt,omitempty"`
	Funcdecl         *FuncDecl       `protobuf:"bytes,25,opt,name=funcdecl" json:"funcdecl,omitempty"`
	Funclit          *FuncLit        `protobuf:"bytes,26,opt,name=funclit" json:"funclit,omitempty"`
	Functype         *FuncType       `protobuf:"bytes,27,opt,name=functype" json:"functype,omitempty"`
	Gendecl          *GenDecl        `protobuf:"bytes,28,opt,name=gendecl" json:"gendecl,omitempty"`
	Gostmt           *GoStmt         `protobuf:"bytes,29,opt,name=gostmt" json:"gostmt,omitempty"`
	Ident            *Ident          `protobuf:"bytes,30,opt,name=ident" json:"ident,omitempty"`
	Ifstmt           *IfStmt         `protobuf:"bytes,31,opt,name=ifstmt" json:"ifstmt,omitempty"`
	Importspec       *ImportSpec     `protobuf:"bytes,32,opt,name=importspec" json:"importspec,omitempty"`
	Incdecstmt       *IncDecStmt     `protobuf:"bytes,33,opt,name=incdecstmt" json:"incdecstmt,omitempty"`
	Indexexpr        *IndexExpr      `protobuf:"bytes,34,opt,name=indexexpr" json:"indexexpr,omitempty"`
	Interfacetype    *InterfaceType  `protobuf:"bytes,35,opt,name=interfacetype" json:"interfacetype,omitempty"`
	Isexported       *IsExported     `protobuf:"bytes,36,opt,name=isexported" json:"isexported,omitempty"`
	Keyvalueexpr     *KeyValueExpr   `protobuf:"bytes,37,opt,name=keyvalueexpr" json:"keyvalueexpr,omitempty"`
	Labeledstmt      *LabeledStmt    `protobuf:"bytes,38,opt,name=labeledstmt" json:"labeledstmt,omitempty"`
	Maptype          *MapType        `protobuf:"bytes,39,opt,name=maptype" json:"maptype,omitempty"`
	Newident         *NewIdent       `protobuf:"bytes,40,opt,name=newident" json:"newident,omitempty"`
	Package          *Package        `protobuf:"bytes,41,opt,name=package" json:"package,omitempty"`
	Parenexpr        *ParenExpr      `protobuf:"bytes,42,opt,name=parenexpr" json:"parenexpr,omitempty"`
	Rangestmt        *RangeStmt      `protobuf:"bytes,43,opt,name=rangestmt" json:"rangestmt,omitempty"`
	Returnstmt       *ReturnStmt     `protobuf:"bytes,44,opt,name=returnstmt" json:"returnstmt,omitempty"`
	Selectstmt       *SelectStmt     `protobuf:"bytes,45,opt,name=selectstmt" json:"selectstmt,omitempty"`
	Selectorexpr     *SelectorExpr   `protobuf:"bytes,46,opt,name=selectorexpr" json:"selectorexpr,omitempty"`
	Sendstmt         *SendStmt       `protobuf:"bytes,47,opt,name=sendstmt" json:"sendstmt,omitempty"`
	Sliceexpr        *SliceExpr      `protobuf:"bytes,48,opt,name=sliceexpr" json:"sliceexpr,omitempty"`
	Spec             *Spec           `protobuf:"bytes,49,opt,name=spec" json:"spec,omitempty"`
	Starexpr         *StarExpr       `protobuf:"bytes,50,opt,name=starexpr" json:"starexpr,omitempty"`
	Structtype       *StructType     `protobuf:"bytes,51,opt,name=structtype" json:"structtype,omitempty"`
	Switchstmt       *SwitchStmt     `protobuf:"bytes,52,opt,name=switchstmt" json:"switchstmt,omitempty"`
	Typeassertexpr   *TypeAssertExpr `protobuf:"bytes,53,opt,name=typeassertexpr" json:"typeassertexpr,omitempty"`
	Typespec         *TypeSpec       `protobuf:"bytes,54,opt,name=typespec" json:"typespec,omitempty"`
	Typeswitchstmt   *TypeSwitchStmt `protobuf:"bytes,55,opt,name=typeswitchstmt" json:"typeswitchstmt,omitempty"`
	Unaryexpr        *UnaryExpr      `protobuf:"bytes,56,opt,name=unaryexpr" json:"unaryexpr,omitempty"`
	Valuespec        *ValueSpec      `protobuf:"bytes,57,opt,name=valuespec" json:"valuespec,omitempty"`
	Commentgroup     *CommentGroup   `protobuf:"bytes,58,opt,name=commentgroup" json:"commentgroup,omitempty"`
	Assignstmt       *AssignStmt     `protobuf:"bytes,59,opt,name=assignstmt" json:"assignstmt,omitempty"`
	Object           *Object         `protobuf:"bytes,60,opt,name=object" json:"object,omitempty"`
	Arraytype        *ArrayType      `protobuf:"bytes,61,opt,name=arraytype" json:"arraytype,omitempty"`
	Deferred         *Deferred       `protobuf:"bytes,62,opt,name=deferred" json:"deferred,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *Foo2) Reset()                    { *m = Foo2{} }
func (m *Foo2) String() string            { return proto.CompactTextString(m) }
func (*Foo2) ProtoMessage()               {}
func (*Foo2) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *Foo2) GetType() NodeType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return NodeType_ARRAYTYPE
}

func (m *Foo2) GetBaddecl() *BadDecl {
	if m != nil {
		return m.Baddecl
	}
	return nil
}

func (m *Foo2) GetBadexpr() *BadExpr {
	if m != nil {
		return m.Badexpr
	}
	return nil
}

func (m *Foo2) GetBadstmt() *BadStmt {
	if m != nil {
		return m.Badstmt
	}
	return nil
}

func (m *Foo2) GetBasiclit() *BasicLit {
	if m != nil {
		return m.Basiclit
	}
	return nil
}

func (m *Foo2) GetBinaryexpr() *BinaryExpr {
	if m != nil {
		return m.Binaryexpr
	}
	return nil
}

func (m *Foo2) GetBlockstmt() *BlockStmt {
	if m != nil {
		return m.Blockstmt
	}
	return nil
}

func (m *Foo2) GetBranchstmt() *BranchStmt {
	if m != nil {
		return m.Branchstmt
	}
	return nil
}

func (m *Foo2) GetCallexpr() *CallExpr {
	if m != nil {
		return m.Callexpr
	}
	return nil
}

func (m *Foo2) GetCaseclause() *CaseClause {
	if m != nil {
		return m.Caseclause
	}
	return nil
}

func (m *Foo2) GetChandir() *ChanDir {
	if m != nil {
		return m.Chandir
	}
	return nil
}

func (m *Foo2) GetChantype() *ChanType {
	if m != nil {
		return m.Chantype
	}
	return nil
}

func (m *Foo2) GetCommclause() *CommClause {
	if m != nil {
		return m.Commclause
	}
	return nil
}

func (m *Foo2) GetComment() *Comment {
	if m != nil {
		return m.Comment
	}
	return nil
}

func (m *Foo2) GetCompositelit() *CompositeLit {
	if m != nil {
		return m.Compositelit
	}
	return nil
}

func (m *Foo2) GetDeclstmt() *DeclStmt {
	if m != nil {
		return m.Declstmt
	}
	return nil
}

func (m *Foo2) GetDeferstmt() *DeferStmt {
	if m != nil {
		return m.Deferstmt
	}
	return nil
}

func (m *Foo2) GetEllipsis() *Ellipsis {
	if m != nil {
		return m.Ellipsis
	}
	return nil
}

func (m *Foo2) GetEmptystmt() *EmptyStmt {
	if m != nil {
		return m.Emptystmt
	}
	return nil
}

func (m *Foo2) GetExprstmt() *ExprStmt {
	if m != nil {
		return m.Exprstmt
	}
	return nil
}

func (m *Foo2) GetField() *Field {
	if m != nil {
		return m.Field
	}
	return nil
}

func (m *Foo2) GetFieldlist() *FieldList {
	if m != nil {
		return m.Fieldlist
	}
	return nil
}

func (m *Foo2) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *Foo2) GetForstmt() *ForStmt {
	if m != nil {
		return m.Forstmt
	}
	return nil
}

func (m *Foo2) GetFuncdecl() *FuncDecl {
	if m != nil {
		return m.Funcdecl
	}
	return nil
}

func (m *Foo2) GetFunclit() *FuncLit {
	if m != nil {
		return m.Funclit
	}
	return nil
}

func (m *Foo2) GetFunctype() *FuncType {
	if m != nil {
		return m.Functype
	}
	return nil
}

func (m *Foo2) GetGendecl() *GenDecl {
	if m != nil {
		return m.Gendecl
	}
	return nil
}

func (m *Foo2) GetGostmt() *GoStmt {
	if m != nil {
		return m.Gostmt
	}
	return nil
}

func (m *Foo2) GetIdent() *Ident {
	if m != nil {
		return m.Ident
	}
	return nil
}

func (m *Foo2) GetIfstmt() *IfStmt {
	if m != nil {
		return m.Ifstmt
	}
	return nil
}

func (m *Foo2) GetImportspec() *ImportSpec {
	if m != nil {
		return m.Importspec
	}
	return nil
}

func (m *Foo2) GetIncdecstmt() *IncDecStmt {
	if m != nil {
		return m.Incdecstmt
	}
	return nil
}

func (m *Foo2) GetIndexexpr() *IndexExpr {
	if m != nil {
		return m.Indexexpr
	}
	return nil
}

func (m *Foo2) GetInterfacetype() *InterfaceType {
	if m != nil {
		return m.Interfacetype
	}
	return nil
}

func (m *Foo2) GetIsexported() *IsExported {
	if m != nil {
		return m.Isexported
	}
	return nil
}

func (m *Foo2) GetKeyvalueexpr() *KeyValueExpr {
	if m != nil {
		return m.Keyvalueexpr
	}
	return nil
}

func (m *Foo2) GetLabeledstmt() *LabeledStmt {
	if m != nil {
		return m.Labeledstmt
	}
	return nil
}

func (m *Foo2) GetMaptype() *MapType {
	if m != nil {
		return m.Maptype
	}
	return nil
}

func (m *Foo2) GetNewident() *NewIdent {
	if m != nil {
		return m.Newident
	}
	return nil
}

func (m *Foo2) GetPackage() *Package {
	if m != nil {
		return m.Package
	}
	return nil
}

func (m *Foo2) GetParenexpr() *ParenExpr {
	if m != nil {
		return m.Parenexpr
	}
	return nil
}

func (m *Foo2) GetRangestmt() *RangeStmt {
	if m != nil {
		return m.Rangestmt
	}
	return nil
}

func (m *Foo2) GetReturnstmt() *ReturnStmt {
	if m != nil {
		return m.Returnstmt
	}
	return nil
}

func (m *Foo2) GetSelectstmt() *SelectStmt {
	if m != nil {
		return m.Selectstmt
	}
	return nil
}

func (m *Foo2) GetSelectorexpr() *SelectorExpr {
	if m != nil {
		return m.Selectorexpr
	}
	return nil
}

func (m *Foo2) GetSendstmt() *SendStmt {
	if m != nil {
		return m.Sendstmt
	}
	return nil
}

func (m *Foo2) GetSliceexpr() *SliceExpr {
	if m != nil {
		return m.Sliceexpr
	}
	return nil
}

func (m *Foo2) GetSpec() *Spec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Foo2) GetStarexpr() *StarExpr {
	if m != nil {
		return m.Starexpr
	}
	return nil
}

func (m *Foo2) GetStructtype() *StructType {
	if m != nil {
		return m.Structtype
	}
	return nil
}

func (m *Foo2) GetSwitchstmt() *SwitchStmt {
	if m != nil {
		return m.Switchstmt
	}
	return nil
}

func (m *Foo2) GetTypeassertexpr() *TypeAssertExpr {
	if m != nil {
		return m.Typeassertexpr
	}
	return nil
}

func (m *Foo2) GetTypespec() *TypeSpec {
	if m != nil {
		return m.Typespec
	}
	return nil
}

func (m *Foo2) GetTypeswitchstmt() *TypeSwitchStmt {
	if m != nil {
		return m.Typeswitchstmt
	}
	return nil
}

func (m *Foo2) GetUnaryexpr() *UnaryExpr {
	if m != nil {
		return m.Unaryexpr
	}
	return nil
}

func (m *Foo2) GetValuespec() *ValueSpec {
	if m != nil {
		return m.Valuespec
	}
	return nil
}

func (m *Foo2) GetCommentgroup() *CommentGroup {
	if m != nil {
		return m.Commentgroup
	}
	return nil
}

func (m *Foo2) GetAssignstmt() *AssignStmt {
	if m != nil {
		return m.Assignstmt
	}
	return nil
}

func (m *Foo2) GetObject() *Object {
	if m != nil {
		return m.Object
	}
	return nil
}

func (m *Foo2) GetArraytype() *ArrayType {
	if m != nil {
		return m.Arraytype
	}
	return nil
}

func (m *Foo2) GetDeferred() *Deferred {
	if m != nil {
		return m.Deferred
	}
	return nil
}

type AssignStmt struct {
	Lhs    []*Expr `protobuf:"bytes,1,rep,name=Lhs,json=lhs" json:"Lhs,omitempty"`
	TokPos *Foo3   `protobuf:"bytes,2,opt,name=TokPos,json=tokPos" json:"TokPos,omitempty"`
	// position of Tok
	Tok *Foo3 `protobuf:"bytes,3,opt,name=Tok,json=tok" json:"Tok,omitempty"`
	// assignment token, DEFINE
	Rhs              []*Expr `protobuf:"bytes,4,rep,name=Rhs,json=rhs" json:"Rhs,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *AssignStmt) Reset()                    { *m = AssignStmt{} }
func (m *AssignStmt) String() string            { return proto.CompactTextString(m) }
func (*AssignStmt) ProtoMessage()               {}
func (*AssignStmt) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *AssignStmt) GetLhs() []*Expr {
	if m != nil {
		return m.Lhs
	}
	return nil
}

func (m *AssignStmt) GetTokPos() *Foo3 {
	if m != nil {
		return m.TokPos
	}
	return nil
}

func (m *AssignStmt) GetTok() *Foo3 {
	if m != nil {
		return m.Tok
	}
	return nil
}

func (m *AssignStmt) GetRhs() []*Expr {
	if m != nil {
		return m.Rhs
	}
	return nil
}

type BadExpr struct {
	From             *Foo2  `protobuf:"bytes,1,opt,name=From,json=from" json:"From,omitempty"`
	To               *Foo2  `protobuf:"bytes,2,opt,name=To,json=to" json:"To,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *BadExpr) Reset()                    { *m = BadExpr{} }
func (m *BadExpr) String() string            { return proto.CompactTextString(m) }
func (*BadExpr) ProtoMessage()               {}
func (*BadExpr) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *BadExpr) GetFrom() *Foo2 {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *BadExpr) GetTo() *Foo2 {
	if m != nil {
		return m.To
	}
	return nil
}

// A BadStmt node is a placeholder for statements containing
// syntax errors for which no correct statement nodes can be
// created.
type BadStmt struct {
	From             *Foo2  `protobuf:"bytes,1,opt,name=From,json=from" json:"From,omitempty"`
	To               *Foo2  `protobuf:"bytes,2,opt,name=To,json=to" json:"To,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *BadStmt) Reset()                    { *m = BadStmt{} }
func (m *BadStmt) String() string            { return proto.CompactTextString(m) }
func (*BadStmt) ProtoMessage()               {}
func (*BadStmt) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *BadStmt) GetFrom() *Foo2 {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *BadStmt) GetTo() *Foo2 {
	if m != nil {
		return m.To
	}
	return nil
}

type BasicLit struct {
	ValuePos         *Foo3   `protobuf:"bytes,1,opt,name=ValuePos,json=valuePos" json:"ValuePos,omitempty"`
	Kind             *string `protobuf:"bytes,2,opt,name=Kind,json=kind" json:"Kind,omitempty"`
	Value            *string `protobuf:"bytes,3,opt,name=Value,json=value" json:"Value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *BasicLit) Reset()                    { *m = BasicLit{} }
func (m *BasicLit) String() string            { return proto.CompactTextString(m) }
func (*BasicLit) ProtoMessage()               {}
func (*BasicLit) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *BasicLit) GetValuePos() *Foo3 {
	if m != nil {
		return m.ValuePos
	}
	return nil
}

func (m *BasicLit) GetKind() string {
	if m != nil && m.Kind != nil {
		return *m.Kind
	}
	return ""
}

func (m *BasicLit) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// A BinaryExpr node represents a binary expression.
type BinaryExpr struct {
	X *Expr `protobuf:"bytes,1,opt,name=X,json=x" json:"X,omitempty"`
	// left operand
	OpPos *Foo3 `protobuf:"bytes,2,opt,name=OpPos,json=opPos" json:"OpPos,omitempty"`
	// position of Op
	Op *Foo3 `protobuf:"bytes,3,opt,name=Op,json=op" json:"Op,omitempty"`
	// operator
	Y                *Expr  `protobuf:"bytes,4,opt,name=Y,json=y" json:"Y,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *BinaryExpr) Reset()                    { *m = BinaryExpr{} }
func (m *BinaryExpr) String() string            { return proto.CompactTextString(m) }
func (*BinaryExpr) ProtoMessage()               {}
func (*BinaryExpr) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *BinaryExpr) GetX() *Expr {
	if m != nil {
		return m.X
	}
	return nil
}

func (m *BinaryExpr) GetOpPos() *Foo3 {
	if m != nil {
		return m.OpPos
	}
	return nil
}

func (m *BinaryExpr) GetOp() *Foo3 {
	if m != nil {
		return m.Op
	}
	return nil
}

func (m *BinaryExpr) GetY() *Expr {
	if m != nil {
		return m.Y
	}
	return nil
}

type BlockStmt struct {
	Lbrace           *Foo3   `protobuf:"bytes,1,opt,name=Lbrace,json=lbrace" json:"Lbrace,omitempty"`
	List             []*Stmt `protobuf:"bytes,2,rep,name=List,json=list" json:"List,omitempty"`
	Rbrace           *Foo3   `protobuf:"bytes,3,opt,name=Rbrace,json=rbrace" json:"Rbrace,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *BlockStmt) Reset()                    { *m = BlockStmt{} }
func (m *BlockStmt) String() string            { return proto.CompactTextString(m) }
func (*BlockStmt) ProtoMessage()               {}
func (*BlockStmt) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *BlockStmt) GetLbrace() *Foo3 {
	if m != nil {
		return m.Lbrace
	}
	return nil
}

func (m *BlockStmt) GetList() []*Stmt {
	if m != nil {
		return m.List
	}
	return nil
}

func (m *BlockStmt) GetRbrace() *Foo3 {
	if m != nil {
		return m.Rbrace
	}
	return nil
}

// A BranchStmt node represents a break, continue, goto,
// or fallthrough statement.
type BranchStmt struct {
	TokPos *Foo3 `protobuf:"bytes,1,opt,name=TokPos,json=tokPos" json:"TokPos,omitempty"`
	Tok    *Foo3 `protobuf:"bytes,2,opt,name=Tok,json=tok" json:"Tok,omitempty"`
	// keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)
	Label            *Ident `protobuf:"bytes,3,opt,name=Label,json=label" json:"Label,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *BranchStmt) Reset()                    { *m = BranchStmt{} }
func (m *BranchStmt) String() string            { return proto.CompactTextString(m) }
func (*BranchStmt) ProtoMessage()               {}
func (*BranchStmt) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *BranchStmt) GetTokPos() *Foo3 {
	if m != nil {
		return m.TokPos
	}
	return nil
}

func (m *BranchStmt) GetTok() *Foo3 {
	if m != nil {
		return m.Tok
	}
	return nil
}

func (m *BranchStmt) GetLabel() *Ident {
	if m != nil {
		return m.Label
	}
	return nil
}

// A CallExpr node represents an expression followed by an argument list.
type CallExpr struct {
	Fun *Expr `protobuf:"bytes,1,req,name=Fun,json=fun" json:"Fun,omitempty"`
	// function expression
	Lparen           *Foo3   `protobuf:"bytes,2,opt,name=Lparen,json=lparen" json:"Lparen,omitempty"`
	Args             []*Expr `protobuf:"bytes,3,rep,name=Args,json=args" json:"Args,omitempty"`
	Ellipsis         *Foo3   `protobuf:"bytes,4,opt,name=Ellipsis,json=ellipsis" json:"Ellipsis,omitempty"`
	Rparen           *Foo3   `protobuf:"bytes,5,opt,name=Rparen,json=rparen" json:"Rparen,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *CallExpr) Reset()                    { *m = CallExpr{} }
func (m *CallExpr) String() string            { return proto.CompactTextString(m) }
func (*CallExpr) ProtoMessage()               {}
func (*CallExpr) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *CallExpr) GetFun() *Expr {
	if m != nil {
		return m.Fun
	}
	return nil
}

func (m *CallExpr) GetLparen() *Foo3 {
	if m != nil {
		return m.Lparen
	}
	return nil
}

func (m *CallExpr) GetArgs() []*Expr {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *CallExpr) GetEllipsis() *Foo3 {
	if m != nil {
		return m.Ellipsis
	}
	return nil
}

func (m *CallExpr) GetRparen() *Foo3 {
	if m != nil {
		return m.Rparen
	}
	return nil
}

// A CaseClause represents a case of an expression or type switch statement.
type CaseClause struct {
	Case *Foo3   `protobuf:"bytes,1,opt,name=Case,json=case" json:"Case,omitempty"`
	List []*Expr `protobuf:"bytes,2,rep,name=List,json=list" json:"List,omitempty"`
	// list of expressions or types; nil means default case
	Colon            *Foo3   `protobuf:"bytes,3,opt,name=Colon,json=colon" json:"Colon,omitempty"`
	Body             []*Stmt `protobuf:"bytes,4,rep,name=Body,json=body" json:"Body,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *CaseClause) Reset()                    { *m = CaseClause{} }
func (m *CaseClause) String() string            { return proto.CompactTextString(m) }
func (*CaseClause) ProtoMessage()               {}
func (*CaseClause) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *CaseClause) GetCase() *Foo3 {
	if m != nil {
		return m.Case
	}
	return nil
}

func (m *CaseClause) GetList() []*Expr {
	if m != nil {
		return m.List
	}
	return nil
}

func (m *CaseClause) GetColon() *Foo3 {
	if m != nil {
		return m.Colon
	}
	return nil
}

func (m *CaseClause) GetBody() []*Stmt {
	if m != nil {
		return m.Body
	}
	return nil
}

// A CommClause node represents a case of a select statement.
type CommClause struct {
	Case *Foo2 `protobuf:"bytes,1,opt,name=Case,json=case" json:"Case,omitempty"`
	// position of "case" or "default" keyword
	Comm *Stmt `protobuf:"bytes,2,req,name=Comm,json=comm" json:"Comm,omitempty"`
	// send or receive statement; nil means default case
	Colon *Foo2 `protobuf:"bytes,3,opt,name=Colon,json=colon" json:"Colon,omitempty"`
	// position of ":"
	Body             []*Stmt `protobuf:"bytes,4,rep,name=Body,json=body" json:"Body,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *CommClause) Reset()                    { *m = CommClause{} }
func (m *CommClause) String() string            { return proto.CompactTextString(m) }
func (*CommClause) ProtoMessage()               {}
func (*CommClause) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *CommClause) GetCase() *Foo2 {
	if m != nil {
		return m.Case
	}
	return nil
}

func (m *CommClause) GetComm() *Stmt {
	if m != nil {
		return m.Comm
	}
	return nil
}

func (m *CommClause) GetColon() *Foo2 {
	if m != nil {
		return m.Colon
	}
	return nil
}

func (m *CommClause) GetBody() []*Stmt {
	if m != nil {
		return m.Body
	}
	return nil
}

// A CompositeLit node represents a composite literal.
type CompositeLit struct {
	Type *Expr `protobuf:"bytes,1,req,name=Type,json=type" json:"Type,omitempty"`
	// literal type; or nil
	Lbrace *Foo3   `protobuf:"bytes,2,opt,name=Lbrace,json=lbrace" json:"Lbrace,omitempty"`
	Elts   []*Expr `protobuf:"bytes,3,rep,name=Elts,json=elts" json:"Elts,omitempty"`
	// []list of composite elements; or nil
	Rbrace           *Foo3  `protobuf:"bytes,4,opt,name=Rbrace,json=rbrace" json:"Rbrace,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *CompositeLit) Reset()                    { *m = CompositeLit{} }
func (m *CompositeLit) String() string            { return proto.CompactTextString(m) }
func (*CompositeLit) ProtoMessage()               {}
func (*CompositeLit) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *CompositeLit) GetType() *Expr {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *CompositeLit) GetLbrace() *Foo3 {
	if m != nil {
		return m.Lbrace
	}
	return nil
}

func (m *CompositeLit) GetElts() []*Expr {
	if m != nil {
		return m.Elts
	}
	return nil
}

func (m *CompositeLit) GetRbrace() *Foo3 {
	if m != nil {
		return m.Rbrace
	}
	return nil
}

// A DeferStmt node represents a defer statement.
type DeferStmt struct {
	Defer            *Foo3     `protobuf:"bytes,1,opt,name=Defer,json=defer" json:"Defer,omitempty"`
	Call             *CallExpr `protobuf:"bytes,2,opt,name=Call,json=call" json:"Call,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *DeferStmt) Reset()                    { *m = DeferStmt{} }
func (m *DeferStmt) String() string            { return proto.CompactTextString(m) }
func (*DeferStmt) ProtoMessage()               {}
func (*DeferStmt) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *DeferStmt) GetDefer() *Foo3 {
	if m != nil {
		return m.Defer
	}
	return nil
}

func (m *DeferStmt) GetCall() *CallExpr {
	if m != nil {
		return m.Call
	}
	return nil
}

// deferred
type Deferred struct {
	Id *string `protobuf:"bytes,1,opt,name=Id,json=id" json:"Id,omitempty"`
	// Data  Foo2
	// Data  int64
	Type             *NodeType `protobuf:"varint,2,req,name=type,enum=github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.NodeType" json:"type,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *Deferred) Reset()                    { *m = Deferred{} }
func (m *Deferred) String() string            { return proto.CompactTextString(m) }
func (*Deferred) ProtoMessage()               {}
func (*Deferred) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *Deferred) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *Deferred) GetType() NodeType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return NodeType_ARRAYTYPE
}

// An Ellipsis node stands for the "..." type in a
// parameter list or the "..." length in an array type.
type Ellipsis struct {
	Ellipsis *Foo3 `protobuf:"bytes,1,opt,name=Ellipsis,json=ellipsis" json:"Ellipsis,omitempty"`
	// position of "..."
	Elt              *Expr  `protobuf:"bytes,2,opt,name=Elt,json=elt" json:"Elt,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Ellipsis) Reset()                    { *m = Ellipsis{} }
func (m *Ellipsis) String() string            { return proto.CompactTextString(m) }
func (*Ellipsis) ProtoMessage()               {}
func (*Ellipsis) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *Ellipsis) GetEllipsis() *Foo3 {
	if m != nil {
		return m.Ellipsis
	}
	return nil
}

func (m *Ellipsis) GetElt() *Expr {
	if m != nil {
		return m.Elt
	}
	return nil
}

// An EmptyStmt node represents an empty statement.
// The "position" of the empty statement is the position
// of the immediately following (explicit or implicit) semicolon.
type EmptyStmt struct {
	Semicolon *Foo2 `protobuf:"bytes,1,opt,name=Semicolon,json=semicolon" json:"Semicolon,omitempty"`
	// position of following ";"
	Implicit         *bool  `protobuf:"varint,2,opt,name=Implicit,json=implicit" json:"Implicit,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EmptyStmt) Reset()                    { *m = EmptyStmt{} }
func (m *EmptyStmt) String() string            { return proto.CompactTextString(m) }
func (*EmptyStmt) ProtoMessage()               {}
func (*EmptyStmt) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *EmptyStmt) GetSemicolon() *Foo2 {
	if m != nil {
		return m.Semicolon
	}
	return nil
}

func (m *EmptyStmt) GetImplicit() bool {
	if m != nil && m.Implicit != nil {
		return *m.Implicit
	}
	return false
}

type Field struct {
	Names            []*Ident      `protobuf:"bytes,1,rep,name=Names,json=names" json:"Names,omitempty"`
	Type             *Expr         `protobuf:"bytes,2,req,name=Type,json=type" json:"Type,omitempty"`
	Tag              *BasicLit     `protobuf:"bytes,3,opt,name=Tag,json=tag" json:"Tag,omitempty"`
	Comment          *CommentGroup `protobuf:"bytes,4,opt,name=Comment,json=comment" json:"Comment,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Field) Reset()                    { *m = Field{} }
func (m *Field) String() string            { return proto.CompactTextString(m) }
func (*Field) ProtoMessage()               {}
func (*Field) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *Field) GetNames() []*Ident {
	if m != nil {
		return m.Names
	}
	return nil
}

func (m *Field) GetType() *Expr {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Field) GetTag() *BasicLit {
	if m != nil {
		return m.Tag
	}
	return nil
}

func (m *Field) GetComment() *CommentGroup {
	if m != nil {
		return m.Comment
	}
	return nil
}

type FieldList struct {
	Opening          *Foo3    `protobuf:"bytes,1,opt,name=Opening,json=opening" json:"Opening,omitempty"`
	List             []*Field `protobuf:"bytes,2,rep,name=List,json=list" json:"List,omitempty"`
	Closing          *Foo3    `protobuf:"bytes,3,opt,name=Closing,json=closing" json:"Closing,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *FieldList) Reset()                    { *m = FieldList{} }
func (m *FieldList) String() string            { return proto.CompactTextString(m) }
func (*FieldList) ProtoMessage()               {}
func (*FieldList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

func (m *FieldList) GetOpening() *Foo3 {
	if m != nil {
		return m.Opening
	}
	return nil
}

func (m *FieldList) GetList() []*Field {
	if m != nil {
		return m.List
	}
	return nil
}

func (m *FieldList) GetClosing() *Foo3 {
	if m != nil {
		return m.Closing
	}
	return nil
}

type File struct {
	Doc              *CommentGroup   `protobuf:"bytes,8,opt,name=Doc,json=doc" json:"Doc,omitempty"`
	Package          *Foo3           `protobuf:"bytes,1,opt,name=Package,json=package" json:"Package,omitempty"`
	Name             *Ident          `protobuf:"bytes,2,opt,name=Name,json=name" json:"Name,omitempty"`
	Decls            []*Decl         `protobuf:"bytes,3,rep,name=Decls,json=decls" json:"Decls,omitempty"`
	Scope            *Scope          `protobuf:"bytes,4,opt,name=Scope,json=scope" json:"Scope,omitempty"`
	Imports          []*ImportSpec   `protobuf:"bytes,5,rep,name=Imports,json=imports" json:"Imports,omitempty"`
	Unresolved       []*Ident        `protobuf:"bytes,6,rep,name=Unresolved,json=unresolved" json:"Unresolved,omitempty"`
	Comments         []*CommentGroup `protobuf:"bytes,7,rep,name=Comments,json=comments" json:"Comments,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *File) Reset()                    { *m = File{} }
func (m *File) String() string            { return proto.CompactTextString(m) }
func (*File) ProtoMessage()               {}
func (*File) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

func (m *File) GetDoc() *CommentGroup {
	if m != nil {
		return m.Doc
	}
	return nil
}

func (m *File) GetPackage() *Foo3 {
	if m != nil {
		return m.Package
	}
	return nil
}

func (m *File) GetName() *Ident {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *File) GetDecls() []*Decl {
	if m != nil {
		return m.Decls
	}
	return nil
}

func (m *File) GetScope() *Scope {
	if m != nil {
		return m.Scope
	}
	return nil
}

func (m *File) GetImports() []*ImportSpec {
	if m != nil {
		return m.Imports
	}
	return nil
}

func (m *File) GetUnresolved() []*Ident {
	if m != nil {
		return m.Unresolved
	}
	return nil
}

func (m *File) GetComments() []*CommentGroup {
	if m != nil {
		return m.Comments
	}
	return nil
}

// A ForStmt represents a for statement.
type ForStmt struct {
	For *Foo3 `protobuf:"bytes,1,opt,name=For,json=for" json:"For,omitempty"`
	// position of "for" keyword
	Init *Stmt `protobuf:"bytes,2,req,name=Init,json=init" json:"Init,omitempty"`
	// initialization statement; or nil
	Cond *Expr `protobuf:"bytes,3,req,name=Cond,json=cond" json:"Cond,omitempty"`
	// condition; or nil
	Post *Stmt `protobuf:"bytes,4,req,name=Post,json=post" json:"Post,omitempty"`
	// post iteration statement; or nil
	Body             *BlockStmt `protobuf:"bytes,5,opt,name=Body,json=body" json:"Body,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *ForStmt) Reset()                    { *m = ForStmt{} }
func (m *ForStmt) String() string            { return proto.CompactTextString(m) }
func (*ForStmt) ProtoMessage()               {}
func (*ForStmt) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

func (m *ForStmt) GetFor() *Foo3 {
	if m != nil {
		return m.For
	}
	return nil
}

func (m *ForStmt) GetInit() *Stmt {
	if m != nil {
		return m.Init
	}
	return nil
}

func (m *ForStmt) GetCond() *Expr {
	if m != nil {
		return m.Cond
	}
	return nil
}

func (m *ForStmt) GetPost() *Stmt {
	if m != nil {
		return m.Post
	}
	return nil
}

func (m *ForStmt) GetBody() *BlockStmt {
	if m != nil {
		return m.Body
	}
	return nil
}

type FuncDecl struct {
	Recv             *FieldList    `protobuf:"bytes,1,opt,name=Recv,json=recv" json:"Recv,omitempty"`
	Name             *Ident        `protobuf:"bytes,2,opt,name=Name,json=name" json:"Name,omitempty"`
	Type             *FuncType     `protobuf:"bytes,3,opt,name=Type,json=type" json:"Type,omitempty"`
	Body             *BlockStmt    `protobuf:"bytes,4,opt,name=Body,json=body" json:"Body,omitempty"`
	Doc              *CommentGroup `protobuf:"bytes,5,opt,name=Doc,json=doc" json:"Doc,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *FuncDecl) Reset()                    { *m = FuncDecl{} }
func (m *FuncDecl) String() string            { return proto.CompactTextString(m) }
func (*FuncDecl) ProtoMessage()               {}
func (*FuncDecl) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38} }

func (m *FuncDecl) GetRecv() *FieldList {
	if m != nil {
		return m.Recv
	}
	return nil
}

func (m *FuncDecl) GetName() *Ident {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *FuncDecl) GetType() *FuncType {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *FuncDecl) GetBody() *BlockStmt {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *FuncDecl) GetDoc() *CommentGroup {
	if m != nil {
		return m.Doc
	}
	return nil
}

// A FuncLit node represents a function literal.
type FuncLit struct {
	Type *FuncType `protobuf:"bytes,1,opt,name=Type,json=type" json:"Type,omitempty"`
	// function type
	Body             *BlockStmt `protobuf:"bytes,2,opt,name=Body,json=body" json:"Body,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *FuncLit) Reset()                    { *m = FuncLit{} }
func (m *FuncLit) String() string            { return proto.CompactTextString(m) }
func (*FuncLit) ProtoMessage()               {}
func (*FuncLit) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39} }

func (m *FuncLit) GetType() *FuncType {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *FuncLit) GetBody() *BlockStmt {
	if m != nil {
		return m.Body
	}
	return nil
}

type FuncType struct {
	Func             *Foo3      `protobuf:"bytes,1,opt,name=Func,json=func" json:"Func,omitempty"`
	Params           *Foo2      `protobuf:"bytes,2,opt,name=Params,json=params" json:"Params,omitempty"`
	Results          *FieldList `protobuf:"bytes,3,opt,name=Results,json=results" json:"Results,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *FuncType) Reset()                    { *m = FuncType{} }
func (m *FuncType) String() string            { return proto.CompactTextString(m) }
func (*FuncType) ProtoMessage()               {}
func (*FuncType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{40} }

func (m *FuncType) GetFunc() *Foo3 {
	if m != nil {
		return m.Func
	}
	return nil
}

func (m *FuncType) GetParams() *Foo2 {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *FuncType) GetResults() *FieldList {
	if m != nil {
		return m.Results
	}
	return nil
}

type GenDecl struct {
	TokPos           *Foo3   `protobuf:"bytes,1,opt,name=TokPos,json=tokPos" json:"TokPos,omitempty"`
	Tok              *Foo3   `protobuf:"bytes,2,opt,name=Tok,json=tok" json:"Tok,omitempty"`
	Lparen           *Foo3   `protobuf:"bytes,3,opt,name=Lparen,json=lparen" json:"Lparen,omitempty"`
	Specs            []*Spec `protobuf:"bytes,4,rep,name=Specs,json=specs" json:"Specs,omitempty"`
	Rparen           *Foo3   `protobuf:"bytes,5,opt,name=Rparen,json=rparen" json:"Rparen,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *GenDecl) Reset()                    { *m = GenDecl{} }
func (m *GenDecl) String() string            { return proto.CompactTextString(m) }
func (*GenDecl) ProtoMessage()               {}
func (*GenDecl) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{41} }

func (m *GenDecl) GetTokPos() *Foo3 {
	if m != nil {
		return m.TokPos
	}
	return nil
}

func (m *GenDecl) GetTok() *Foo3 {
	if m != nil {
		return m.Tok
	}
	return nil
}

func (m *GenDecl) GetLparen() *Foo3 {
	if m != nil {
		return m.Lparen
	}
	return nil
}

func (m *GenDecl) GetSpecs() []*Spec {
	if m != nil {
		return m.Specs
	}
	return nil
}

func (m *GenDecl) GetRparen() *Foo3 {
	if m != nil {
		return m.Rparen
	}
	return nil
}

// A GoStmt node represents a go statement.
type GoStmt struct {
	Go *Foo2 `protobuf:"bytes,1,opt,name=Go,json=go" json:"Go,omitempty"`
	// position of "go" keyword
	Call             *CallExpr `protobuf:"bytes,2,opt,name=Call,json=call" json:"Call,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *GoStmt) Reset()                    { *m = GoStmt{} }
func (m *GoStmt) String() string            { return proto.CompactTextString(m) }
func (*GoStmt) ProtoMessage()               {}
func (*GoStmt) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{42} }

func (m *GoStmt) GetGo() *Foo2 {
	if m != nil {
		return m.Go
	}
	return nil
}

func (m *GoStmt) GetCall() *CallExpr {
	if m != nil {
		return m.Call
	}
	return nil
}

type Ident struct {
	NamePos          *Foo3   `protobuf:"bytes,1,opt,name=NamePos,json=namePos" json:"NamePos,omitempty"`
	Name             *string `protobuf:"bytes,2,opt,name=Name,json=name" json:"Name,omitempty"`
	Obj              *Foo2   `protobuf:"bytes,3,opt,name=Obj,json=obj" json:"Obj,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Ident) Reset()                    { *m = Ident{} }
func (m *Ident) String() string            { return proto.CompactTextString(m) }
func (*Ident) ProtoMessage()               {}
func (*Ident) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{43} }

func (m *Ident) GetNamePos() *Foo3 {
	if m != nil {
		return m.NamePos
	}
	return nil
}

func (m *Ident) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Ident) GetObj() *Foo2 {
	if m != nil {
		return m.Obj
	}
	return nil
}

// An IfStmt node represents an if statement.
type IfStmt struct {
	If   *Foo3 `protobuf:"bytes,1,opt,name=If,json=if" json:"If,omitempty"`
	Init *Stmt `protobuf:"bytes,2,req,name=Init,json=init" json:"Init,omitempty"`
	// initialization statement; or nil
	Cond *Expr `protobuf:"bytes,3,req,name=Cond,json=cond" json:"Cond,omitempty"`
	// condition
	Body             *BlockStmt `protobuf:"bytes,4,opt,name=Body,json=body" json:"Body,omitempty"`
	Else             *Stmt      `protobuf:"bytes,5,opt,name=Else,json=else" json:"Else,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *IfStmt) Reset()                    { *m = IfStmt{} }
func (m *IfStmt) String() string            { return proto.CompactTextString(m) }
func (*IfStmt) ProtoMessage()               {}
func (*IfStmt) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{44} }

func (m *IfStmt) GetIf() *Foo3 {
	if m != nil {
		return m.If
	}
	return nil
}

func (m *IfStmt) GetInit() *Stmt {
	if m != nil {
		return m.Init
	}
	return nil
}

func (m *IfStmt) GetCond() *Expr {
	if m != nil {
		return m.Cond
	}
	return nil
}

func (m *IfStmt) GetBody() *BlockStmt {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *IfStmt) GetElse() *Stmt {
	if m != nil {
		return m.Else
	}
	return nil
}

// An IncDecStmt node represents an increment or decrement statement.
type IncDecStmt struct {
	X      *Expr `protobuf:"bytes,1,opt,name=X,json=x" json:"X,omitempty"`
	TokPos *Foo3 `protobuf:"bytes,2,opt,name=TokPos,json=tokPos" json:"TokPos,omitempty"`
	// position of Tok
	Tok              *Foo3  `protobuf:"bytes,3,opt,name=Tok,json=tok" json:"Tok,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *IncDecStmt) Reset()                    { *m = IncDecStmt{} }
func (m *IncDecStmt) String() string            { return proto.CompactTextString(m) }
func (*IncDecStmt) ProtoMessage()               {}
func (*IncDecStmt) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{45} }

func (m *IncDecStmt) GetX() *Expr {
	if m != nil {
		return m.X
	}
	return nil
}

func (m *IncDecStmt) GetTokPos() *Foo3 {
	if m != nil {
		return m.TokPos
	}
	return nil
}

func (m *IncDecStmt) GetTok() *Foo3 {
	if m != nil {
		return m.Tok
	}
	return nil
}

// An IndexExpr node represents an expression followed by an index.
type IndexExpr struct {
	X *Expr `protobuf:"bytes,1,req,name=X,json=x" json:"X,omitempty"`
	// expression
	Lbrack *Foo3 `protobuf:"bytes,2,opt,name=Lbrack,json=lbrack" json:"Lbrack,omitempty"`
	Index  *Expr `protobuf:"bytes,3,req,name=Index,json=index" json:"Index,omitempty"`
	// index expression
	Rbrack           *Foo3  `protobuf:"bytes,4,opt,name=Rbrack,json=rbrack" json:"Rbrack,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *IndexExpr) Reset()                    { *m = IndexExpr{} }
func (m *IndexExpr) String() string            { return proto.CompactTextString(m) }
func (*IndexExpr) ProtoMessage()               {}
func (*IndexExpr) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{46} }

func (m *IndexExpr) GetX() *Expr {
	if m != nil {
		return m.X
	}
	return nil
}

func (m *IndexExpr) GetLbrack() *Foo3 {
	if m != nil {
		return m.Lbrack
	}
	return nil
}

func (m *IndexExpr) GetIndex() *Expr {
	if m != nil {
		return m.Index
	}
	return nil
}

func (m *IndexExpr) GetRbrack() *Foo3 {
	if m != nil {
		return m.Rbrack
	}
	return nil
}

type InterfaceType struct {
	Interface        *Foo3      `protobuf:"bytes,1,opt,name=Interface,json=interface" json:"Interface,omitempty"`
	Methods          *FieldList `protobuf:"bytes,2,opt,name=Methods,json=methods" json:"Methods,omitempty"`
	Incomplete       *bool      `protobuf:"varint,3,opt,name=Incomplete,json=incomplete" json:"Incomplete,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *InterfaceType) Reset()                    { *m = InterfaceType{} }
func (m *InterfaceType) String() string            { return proto.CompactTextString(m) }
func (*InterfaceType) ProtoMessage()               {}
func (*InterfaceType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{47} }

func (m *InterfaceType) GetInterface() *Foo3 {
	if m != nil {
		return m.Interface
	}
	return nil
}

func (m *InterfaceType) GetMethods() *FieldList {
	if m != nil {
		return m.Methods
	}
	return nil
}

func (m *InterfaceType) GetIncomplete() bool {
	if m != nil && m.Incomplete != nil {
		return *m.Incomplete
	}
	return false
}

// A KeyValueExpr node represents (key : value) pairs
// in composite literals.
type KeyValueExpr struct {
	Key   *Expr `protobuf:"bytes,1,opt,name=Key,json=key" json:"Key,omitempty"`
	Colon *Foo3 `protobuf:"bytes,2,opt,name=Colon,json=colon" json:"Colon,omitempty"`
	// position of ":"
	Value            *Expr  `protobuf:"bytes,3,opt,name=Value,json=value" json:"Value,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *KeyValueExpr) Reset()                    { *m = KeyValueExpr{} }
func (m *KeyValueExpr) String() string            { return proto.CompactTextString(m) }
func (*KeyValueExpr) ProtoMessage()               {}
func (*KeyValueExpr) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{48} }

func (m *KeyValueExpr) GetKey() *Expr {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *KeyValueExpr) GetColon() *Foo3 {
	if m != nil {
		return m.Colon
	}
	return nil
}

func (m *KeyValueExpr) GetValue() *Expr {
	if m != nil {
		return m.Value
	}
	return nil
}

// A LabeledStmt node represents a labeled statement.
type LabeledStmt struct {
	Label *Ident `protobuf:"bytes,1,opt,name=Label,json=label" json:"Label,omitempty"`
	Colon *Foo3  `protobuf:"bytes,2,opt,name=Colon,json=colon" json:"Colon,omitempty"`
	// position of ":"
	Stmt             *Stmt  `protobuf:"bytes,3,req,name=Stmt,json=stmt" json:"Stmt,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *LabeledStmt) Reset()                    { *m = LabeledStmt{} }
func (m *LabeledStmt) String() string            { return proto.CompactTextString(m) }
func (*LabeledStmt) ProtoMessage()               {}
func (*LabeledStmt) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{49} }

func (m *LabeledStmt) GetLabel() *Ident {
	if m != nil {
		return m.Label
	}
	return nil
}

func (m *LabeledStmt) GetColon() *Foo3 {
	if m != nil {
		return m.Colon
	}
	return nil
}

func (m *LabeledStmt) GetStmt() *Stmt {
	if m != nil {
		return m.Stmt
	}
	return nil
}

type MapType struct {
	Map              *Foo3  `protobuf:"bytes,1,opt,name=Map,json=map" json:"Map,omitempty"`
	Key              *Expr  `protobuf:"bytes,2,opt,name=Key,json=key" json:"Key,omitempty"`
	Value            *Expr  `protobuf:"bytes,3,opt,name=Value,json=value" json:"Value,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *MapType) Reset()                    { *m = MapType{} }
func (m *MapType) String() string            { return proto.CompactTextString(m) }
func (*MapType) ProtoMessage()               {}
func (*MapType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{50} }

func (m *MapType) GetMap() *Foo3 {
	if m != nil {
		return m.Map
	}
	return nil
}

func (m *MapType) GetKey() *Expr {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *MapType) GetValue() *Expr {
	if m != nil {
		return m.Value
	}
	return nil
}

type Object struct {
	Deferred         *Deferred `protobuf:"bytes,1,opt,name=Deferred,json=deferred" json:"Deferred,omitempty"`
	Kind             *string   `protobuf:"bytes,2,opt,name=Kind,json=kind" json:"Kind,omitempty"`
	Name             *string   `protobuf:"bytes,3,opt,name=Name,json=name" json:"Name,omitempty"`
	Decl             *Foo2     `protobuf:"bytes,4,opt,name=Decl,json=decl" json:"Decl,omitempty"`
	Data             *Foo3     `protobuf:"bytes,5,opt,name=Data,json=data" json:"Data,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *Object) Reset()                    { *m = Object{} }
func (m *Object) String() string            { return proto.CompactTextString(m) }
func (*Object) ProtoMessage()               {}
func (*Object) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{51} }

func (m *Object) GetDeferred() *Deferred {
	if m != nil {
		return m.Deferred
	}
	return nil
}

func (m *Object) GetKind() string {
	if m != nil && m.Kind != nil {
		return *m.Kind
	}
	return ""
}

func (m *Object) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Object) GetDecl() *Foo2 {
	if m != nil {
		return m.Decl
	}
	return nil
}

func (m *Object) GetData() *Foo3 {
	if m != nil {
		return m.Data
	}
	return nil
}

type Package struct {
	Name *string `protobuf:"bytes,1,opt,name=Name,json=name" json:"Name,omitempty"`
	// package name
	Scope *Foo2 `protobuf:"bytes,2,opt,name=Scope,json=scope" json:"Scope,omitempty"`
	// package scope across all files
	Imports map[string]*Object `protobuf:"bytes,3,rep,name=Imports,json=imports" json:"Imports,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// map of package id -> package object
	Files            map[string]*File `protobuf:"bytes,4,rep,name=Files,json=files" json:"Files,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *Package) Reset()                    { *m = Package{} }
func (m *Package) String() string            { return proto.CompactTextString(m) }
func (*Package) ProtoMessage()               {}
func (*Package) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{52} }

func (m *Package) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Package) GetScope() *Foo2 {
	if m != nil {
		return m.Scope
	}
	return nil
}

func (m *Package) GetImports() map[string]*Object {
	if m != nil {
		return m.Imports
	}
	return nil
}

func (m *Package) GetFiles() map[string]*File {
	if m != nil {
		return m.Files
	}
	return nil
}

// A ParenFoo2 node represents a parenthesized expression.
type ParenExpr struct {
	Lparen *Foo3 `protobuf:"bytes,1,req,name=Lparen,json=lparen" json:"Lparen,omitempty"`
	X      *Expr `protobuf:"bytes,2,req,name=X,json=x" json:"X,omitempty"`
	// parenthesized expression
	Rparen           *Foo3  `protobuf:"bytes,3,req,name=Rparen,json=rparen" json:"Rparen,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ParenExpr) Reset()                    { *m = ParenExpr{} }
func (m *ParenExpr) String() string            { return proto.CompactTextString(m) }
func (*ParenExpr) ProtoMessage()               {}
func (*ParenExpr) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{53} }

func (m *ParenExpr) GetLparen() *Foo3 {
	if m != nil {
		return m.Lparen
	}
	return nil
}

func (m *ParenExpr) GetX() *Expr {
	if m != nil {
		return m.X
	}
	return nil
}

func (m *ParenExpr) GetRparen() *Foo3 {
	if m != nil {
		return m.Rparen
	}
	return nil
}

// A RangeStmt represents a for statement with a range clause.
type RangeStmt struct {
	For   *Foo3 `protobuf:"bytes,1,req,name=For,json=for" json:"For,omitempty"`
	Key   *Expr `protobuf:"bytes,2,req,name=Key,json=key" json:"Key,omitempty"`
	Value *Expr `protobuf:"bytes,3,req,name=Value,json=value" json:"Value,omitempty"`
	// Key, Value may be nil
	TokPos *Foo3 `protobuf:"bytes,4,req,name=TokPos,json=tokPos" json:"TokPos,omitempty"`
	Tok    *Foo3 `protobuf:"bytes,5,req,name=Tok,json=tok" json:"Tok,omitempty"`
	// ILLEGAL if Key == nil, ASSIGN, DEFINE
	X *Expr `protobuf:"bytes,6,req,name=X,json=x" json:"X,omitempty"`
	// Expr        // value to range over
	Body             *BlockStmt `protobuf:"bytes,7,opt,name=Body,json=body" json:"Body,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *RangeStmt) Reset()                    { *m = RangeStmt{} }
func (m *RangeStmt) String() string            { return proto.CompactTextString(m) }
func (*RangeStmt) ProtoMessage()               {}
func (*RangeStmt) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{54} }

func (m *RangeStmt) GetFor() *Foo3 {
	if m != nil {
		return m.For
	}
	return nil
}

func (m *RangeStmt) GetKey() *Expr {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *RangeStmt) GetValue() *Expr {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *RangeStmt) GetTokPos() *Foo3 {
	if m != nil {
		return m.TokPos
	}
	return nil
}

func (m *RangeStmt) GetTok() *Foo3 {
	if m != nil {
		return m.Tok
	}
	return nil
}

func (m *RangeStmt) GetX() *Expr {
	if m != nil {
		return m.X
	}
	return nil
}

func (m *RangeStmt) GetBody() *BlockStmt {
	if m != nil {
		return m.Body
	}
	return nil
}

type Scope struct {
	Objects          map[string]*Object `protobuf:"bytes,1,rep,name=Objects,json=objects" json:"Objects,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *Scope) Reset()                    { *m = Scope{} }
func (m *Scope) String() string            { return proto.CompactTextString(m) }
func (*Scope) ProtoMessage()               {}
func (*Scope) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{55} }

func (m *Scope) GetObjects() map[string]*Object {
	if m != nil {
		return m.Objects
	}
	return nil
}

// An SelectStmt node represents a select statement.
type SelectStmt struct {
	Select *Foo2 `protobuf:"bytes,1,opt,name=Select,json=select" json:"Select,omitempty"`
	// position of "select" keyword
	Body             *BlockStmt `protobuf:"bytes,2,opt,name=Body,json=body" json:"Body,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *SelectStmt) Reset()                    { *m = SelectStmt{} }
func (m *SelectStmt) String() string            { return proto.CompactTextString(m) }
func (*SelectStmt) ProtoMessage()               {}
func (*SelectStmt) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{56} }

func (m *SelectStmt) GetSelect() *Foo2 {
	if m != nil {
		return m.Select
	}
	return nil
}

func (m *SelectStmt) GetBody() *BlockStmt {
	if m != nil {
		return m.Body
	}
	return nil
}

type SelectorExpr struct {
	X                *Expr  `protobuf:"bytes,1,req,name=X,json=x" json:"X,omitempty"`
	Sel              *Ident `protobuf:"bytes,2,opt,name=Sel,json=sel" json:"Sel,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SelectorExpr) Reset()                    { *m = SelectorExpr{} }
func (m *SelectorExpr) String() string            { return proto.CompactTextString(m) }
func (*SelectorExpr) ProtoMessage()               {}
func (*SelectorExpr) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{57} }

func (m *SelectorExpr) GetX() *Expr {
	if m != nil {
		return m.X
	}
	return nil
}

func (m *SelectorExpr) GetSel() *Ident {
	if m != nil {
		return m.Sel
	}
	return nil
}

// A SendStmt node represents a send statement.
type SendStmt struct {
	Chan             *Expr  `protobuf:"bytes,1,req,name=Chan,json=chan" json:"Chan,omitempty"`
	Arrow            *Foo2  `protobuf:"bytes,2,opt,name=Arrow,json=arrow" json:"Arrow,omitempty"`
	Value            *Expr  `protobuf:"bytes,3,req,name=Value,json=value" json:"Value,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SendStmt) Reset()                    { *m = SendStmt{} }
func (m *SendStmt) String() string            { return proto.CompactTextString(m) }
func (*SendStmt) ProtoMessage()               {}
func (*SendStmt) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{58} }

func (m *SendStmt) GetChan() *Expr {
	if m != nil {
		return m.Chan
	}
	return nil
}

func (m *SendStmt) GetArrow() *Foo2 {
	if m != nil {
		return m.Arrow
	}
	return nil
}

func (m *SendStmt) GetValue() *Expr {
	if m != nil {
		return m.Value
	}
	return nil
}

// An SliceExpr node represents an expression followed by slice indices.
type SliceExpr struct {
	X *Expr `protobuf:"bytes,1,opt,name=X,json=x" json:"X,omitempty"`
	// expression
	Lbrack *Foo3 `protobuf:"bytes,2,opt,name=Lbrack,json=lbrack" json:"Lbrack,omitempty"`
	Low    *Expr `protobuf:"bytes,3,opt,name=Low,json=low" json:"Low,omitempty"`
	// begin of slice range; or nil
	High *Expr `protobuf:"bytes,4,opt,name=High,json=high" json:"High,omitempty"`
	// end of slice range; or nil
	Max *Expr `protobuf:"bytes,5,opt,name=Max,json=max" json:"Max,omitempty"`
	// maximum capacity of slice; or nil
	Slice3 *bool `protobuf:"varint,6,opt,name=Slice3,json=slice3" json:"Slice3,omitempty"`
	// true if 3-index slice (2 colons present)
	Rbrack           *Foo3  `protobuf:"bytes,7,opt,name=Rbrack,json=rbrack" json:"Rbrack,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SliceExpr) Reset()                    { *m = SliceExpr{} }
func (m *SliceExpr) String() string            { return proto.CompactTextString(m) }
func (*SliceExpr) ProtoMessage()               {}
func (*SliceExpr) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{59} }

func (m *SliceExpr) GetX() *Expr {
	if m != nil {
		return m.X
	}
	return nil
}

func (m *SliceExpr) GetLbrack() *Foo3 {
	if m != nil {
		return m.Lbrack
	}
	return nil
}

func (m *SliceExpr) GetLow() *Expr {
	if m != nil {
		return m.Low
	}
	return nil
}

func (m *SliceExpr) GetHigh() *Expr {
	if m != nil {
		return m.High
	}
	return nil
}

func (m *SliceExpr) GetMax() *Expr {
	if m != nil {
		return m.Max
	}
	return nil
}

func (m *SliceExpr) GetSlice3() bool {
	if m != nil && m.Slice3 != nil {
		return *m.Slice3
	}
	return false
}

func (m *SliceExpr) GetRbrack() *Foo3 {
	if m != nil {
		return m.Rbrack
	}
	return nil
}

type StructType struct {
	Struct           *Foo3      `protobuf:"bytes,1,opt,name=Struct,json=struct" json:"Struct,omitempty"`
	Fields           *FieldList `protobuf:"bytes,2,opt,name=Fields,json=fields" json:"Fields,omitempty"`
	Incomplete       *bool      `protobuf:"varint,3,opt,name=Incomplete,json=incomplete" json:"Incomplete,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *StructType) Reset()                    { *m = StructType{} }
func (m *StructType) String() string            { return proto.CompactTextString(m) }
func (*StructType) ProtoMessage()               {}
func (*StructType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{60} }

func (m *StructType) GetStruct() *Foo3 {
	if m != nil {
		return m.Struct
	}
	return nil
}

func (m *StructType) GetFields() *FieldList {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *StructType) GetIncomplete() bool {
	if m != nil && m.Incomplete != nil {
		return *m.Incomplete
	}
	return false
}

// A SwitchStmt node represents an expression switch statement.
type SwitchStmt struct {
	Switch *Foo3 `protobuf:"bytes,1,opt,name=Switch,json=switch" json:"Switch,omitempty"`
	// position of "switch" keyword
	Init *Stmt `protobuf:"bytes,2,req,name=Init,json=init" json:"Init,omitempty"`
	// initialization statement; or nil
	Tag *Expr `protobuf:"bytes,3,req,name=Tag,json=tag" json:"Tag,omitempty"`
	// tag expression; or nil
	Body             *BlockStmt `protobuf:"bytes,4,opt,name=Body,json=body" json:"Body,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *SwitchStmt) Reset()                    { *m = SwitchStmt{} }
func (m *SwitchStmt) String() string            { return proto.CompactTextString(m) }
func (*SwitchStmt) ProtoMessage()               {}
func (*SwitchStmt) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{61} }

func (m *SwitchStmt) GetSwitch() *Foo3 {
	if m != nil {
		return m.Switch
	}
	return nil
}

func (m *SwitchStmt) GetInit() *Stmt {
	if m != nil {
		return m.Init
	}
	return nil
}

func (m *SwitchStmt) GetTag() *Expr {
	if m != nil {
		return m.Tag
	}
	return nil
}

func (m *SwitchStmt) GetBody() *BlockStmt {
	if m != nil {
		return m.Body
	}
	return nil
}

type ArrayType struct {
	Lbrack           *Foo3  `protobuf:"bytes,1,req,name=Lbrack,json=lbrack" json:"Lbrack,omitempty"`
	Elt              *Expr  `protobuf:"bytes,2,req,name=Elt,json=elt" json:"Elt,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ArrayType) Reset()                    { *m = ArrayType{} }
func (m *ArrayType) String() string            { return proto.CompactTextString(m) }
func (*ArrayType) ProtoMessage()               {}
func (*ArrayType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{62} }

func (m *ArrayType) GetLbrack() *Foo3 {
	if m != nil {
		return m.Lbrack
	}
	return nil
}

func (m *ArrayType) GetElt() *Expr {
	if m != nil {
		return m.Elt
	}
	return nil
}

// A TypeAssertExpr node represents an expression followed by a
// type assertion.
type TypeAssertExpr struct {
	X *Expr `protobuf:"bytes,1,req,name=X,json=x" json:"X,omitempty"`
	// expression
	Lparen *Foo3 `protobuf:"bytes,2,opt,name=Lparen,json=lparen" json:"Lparen,omitempty"`
	Type   *Expr `protobuf:"bytes,3,opt,name=Type,json=type" json:"Type,omitempty"`
	// asserted type; nil means type switch X.(type)
	Rparen           *Foo3  `protobuf:"bytes,4,opt,name=Rparen,json=rparen" json:"Rparen,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *TypeAssertExpr) Reset()                    { *m = TypeAssertExpr{} }
func (m *TypeAssertExpr) String() string            { return proto.CompactTextString(m) }
func (*TypeAssertExpr) ProtoMessage()               {}
func (*TypeAssertExpr) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{63} }

func (m *TypeAssertExpr) GetX() *Expr {
	if m != nil {
		return m.X
	}
	return nil
}

func (m *TypeAssertExpr) GetLparen() *Foo3 {
	if m != nil {
		return m.Lparen
	}
	return nil
}

func (m *TypeAssertExpr) GetType() *Expr {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *TypeAssertExpr) GetRparen() *Foo3 {
	if m != nil {
		return m.Rparen
	}
	return nil
}

type TypeSpec struct {
	Name             *Ident        `protobuf:"bytes,1,opt,name=Name,json=name" json:"Name,omitempty"`
	Type             *Expr         `protobuf:"bytes,2,req,name=Type,json=type" json:"Type,omitempty"`
	Doc              *CommentGroup `protobuf:"bytes,3,opt,name=Doc,json=doc" json:"Doc,omitempty"`
	Comment          *CommentGroup `protobuf:"bytes,4,opt,name=Comment,json=comment" json:"Comment,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *TypeSpec) Reset()                    { *m = TypeSpec{} }
func (m *TypeSpec) String() string            { return proto.CompactTextString(m) }
func (*TypeSpec) ProtoMessage()               {}
func (*TypeSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{64} }

func (m *TypeSpec) GetName() *Ident {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *TypeSpec) GetType() *Expr {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *TypeSpec) GetDoc() *CommentGroup {
	if m != nil {
		return m.Doc
	}
	return nil
}

func (m *TypeSpec) GetComment() *CommentGroup {
	if m != nil {
		return m.Comment
	}
	return nil
}

// An TypeSwitchStmt node represents a type switch statement.
type TypeSwitchStmt struct {
	Switch *Foo2 `protobuf:"bytes,1,opt,name=Switch,json=switch" json:"Switch,omitempty"`
	// position of "switch" keyword
	Init *Stmt `protobuf:"bytes,2,req,name=Init,json=init" json:"Init,omitempty"`
	// initialization statement; or nil
	Assign *Stmt `protobuf:"bytes,3,req,name=Assign,json=assign" json:"Assign,omitempty"`
	// x := y.(type) or y.(type)
	Body             *BlockStmt `protobuf:"bytes,4,opt,name=Body,json=body" json:"Body,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *TypeSwitchStmt) Reset()                    { *m = TypeSwitchStmt{} }
func (m *TypeSwitchStmt) String() string            { return proto.CompactTextString(m) }
func (*TypeSwitchStmt) ProtoMessage()               {}
func (*TypeSwitchStmt) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{65} }

func (m *TypeSwitchStmt) GetSwitch() *Foo2 {
	if m != nil {
		return m.Switch
	}
	return nil
}

func (m *TypeSwitchStmt) GetInit() *Stmt {
	if m != nil {
		return m.Init
	}
	return nil
}

func (m *TypeSwitchStmt) GetAssign() *Stmt {
	if m != nil {
		return m.Assign
	}
	return nil
}

func (m *TypeSwitchStmt) GetBody() *BlockStmt {
	if m != nil {
		return m.Body
	}
	return nil
}

// A UnaryExpr node represents a unary expression.
// Unary "*" expressions are represented via StarExpr nodes.
type UnaryExpr struct {
	OpPos *Foo3 `protobuf:"bytes,1,opt,name=OpPos,json=opPos" json:"OpPos,omitempty"`
	Op    *Foo3 `protobuf:"bytes,2,opt,name=Op,json=op" json:"Op,omitempty"`
	// operator
	X                *Expr  `protobuf:"bytes,3,req,name=X,json=x" json:"X,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *UnaryExpr) Reset()                    { *m = UnaryExpr{} }
func (m *UnaryExpr) String() string            { return proto.CompactTextString(m) }
func (*UnaryExpr) ProtoMessage()               {}
func (*UnaryExpr) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{66} }

func (m *UnaryExpr) GetOpPos() *Foo3 {
	if m != nil {
		return m.OpPos
	}
	return nil
}

func (m *UnaryExpr) GetOp() *Foo3 {
	if m != nil {
		return m.Op
	}
	return nil
}

func (m *UnaryExpr) GetX() *Expr {
	if m != nil {
		return m.X
	}
	return nil
}

type ValueSpec struct {
	Names            []*Ident `protobuf:"bytes,1,rep,name=Names,json=names" json:"Names,omitempty"`
	Type             *Expr    `protobuf:"bytes,2,req,name=Type,json=type" json:"Type,omitempty"`
	Values           []*Expr  `protobuf:"bytes,3,rep,name=Values,json=values" json:"Values,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ValueSpec) Reset()                    { *m = ValueSpec{} }
func (m *ValueSpec) String() string            { return proto.CompactTextString(m) }
func (*ValueSpec) ProtoMessage()               {}
func (*ValueSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{67} }

func (m *ValueSpec) GetNames() []*Ident {
	if m != nil {
		return m.Names
	}
	return nil
}

func (m *ValueSpec) GetType() *Expr {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *ValueSpec) GetValues() []*Expr {
	if m != nil {
		return m.Values
	}
	return nil
}

func init() {
	proto.RegisterType((*ExprStmt)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.ExprStmt")
	proto.RegisterType((*StarExpr)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.StarExpr")
	proto.RegisterType((*DeclStmt)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.DeclStmt")
	proto.RegisterType((*BadDecl)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.BadDecl")
	proto.RegisterType((*ChanDir)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.ChanDir")
	proto.RegisterType((*ChanType)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.ChanType")
	proto.RegisterType((*Comment)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.Comment")
	proto.RegisterType((*ReturnStmt)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.ReturnStmt")
	proto.RegisterType((*IsExported)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.IsExported")
	proto.RegisterType((*NewIdent)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.NewIdent")
	proto.RegisterType((*Node)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.Node")
	proto.RegisterType((*Expr)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.Expr")
	proto.RegisterType((*Stmt)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.Stmt")
	proto.RegisterType((*Decl)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.Decl")
	proto.RegisterType((*Spec)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.Spec")
	proto.RegisterType((*ImportSpec)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.ImportSpec")
	proto.RegisterType((*CommentGroup)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.CommentGroup")
	proto.RegisterType((*Foo3)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.Foo3")
	proto.RegisterType((*Foo2)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.Foo2")
	proto.RegisterType((*AssignStmt)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.AssignStmt")
	proto.RegisterType((*BadExpr)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.BadExpr")
	proto.RegisterType((*BadStmt)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.BadStmt")
	proto.RegisterType((*BasicLit)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.BasicLit")
	proto.RegisterType((*BinaryExpr)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.BinaryExpr")
	proto.RegisterType((*BlockStmt)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.BlockStmt")
	proto.RegisterType((*BranchStmt)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.BranchStmt")
	proto.RegisterType((*CallExpr)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.CallExpr")
	proto.RegisterType((*CaseClause)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.CaseClause")
	proto.RegisterType((*CommClause)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.CommClause")
	proto.RegisterType((*CompositeLit)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.CompositeLit")
	proto.RegisterType((*DeferStmt)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.DeferStmt")
	proto.RegisterType((*Deferred)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.Deferred")
	proto.RegisterType((*Ellipsis)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.Ellipsis")
	proto.RegisterType((*EmptyStmt)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.EmptyStmt")
	proto.RegisterType((*Field)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.Field")
	proto.RegisterType((*FieldList)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.FieldList")
	proto.RegisterType((*File)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.File")
	proto.RegisterType((*ForStmt)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.ForStmt")
	proto.RegisterType((*FuncDecl)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.FuncDecl")
	proto.RegisterType((*FuncLit)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.FuncLit")
	proto.RegisterType((*FuncType)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.FuncType")
	proto.RegisterType((*GenDecl)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.GenDecl")
	proto.RegisterType((*GoStmt)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.GoStmt")
	proto.RegisterType((*Ident)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.Ident")
	proto.RegisterType((*IfStmt)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.IfStmt")
	proto.RegisterType((*IncDecStmt)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.IncDecStmt")
	proto.RegisterType((*IndexExpr)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.IndexExpr")
	proto.RegisterType((*InterfaceType)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.InterfaceType")
	proto.RegisterType((*KeyValueExpr)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.KeyValueExpr")
	proto.RegisterType((*LabeledStmt)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.LabeledStmt")
	proto.RegisterType((*MapType)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.MapType")
	proto.RegisterType((*Object)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.Object")
	proto.RegisterType((*Package)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.Package")
	proto.RegisterType((*ParenExpr)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.ParenExpr")
	proto.RegisterType((*RangeStmt)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.RangeStmt")
	proto.RegisterType((*Scope)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.Scope")
	proto.RegisterType((*SelectStmt)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.SelectStmt")
	proto.RegisterType((*SelectorExpr)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.SelectorExpr")
	proto.RegisterType((*SendStmt)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.SendStmt")
	proto.RegisterType((*SliceExpr)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.SliceExpr")
	proto.RegisterType((*StructType)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.StructType")
	proto.RegisterType((*SwitchStmt)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.SwitchStmt")
	proto.RegisterType((*ArrayType)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.ArrayType")
	proto.RegisterType((*TypeAssertExpr)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.TypeAssertExpr")
	proto.RegisterType((*TypeSpec)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.TypeSpec")
	proto.RegisterType((*TypeSwitchStmt)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.TypeSwitchStmt")
	proto.RegisterType((*UnaryExpr)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.UnaryExpr")
	proto.RegisterType((*ValueSpec)(nil), "github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.ValueSpec")
	proto.RegisterEnum("github.com.h4ck3rm1k3.gogccintro.fakego.ast.proto.NodeType", NodeType_name, NodeType_value)
}

func init() { proto.RegisterFile("generated.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 4102 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xec, 0x9c, 0x5d, 0x8c, 0xe4, 0xd8,
	0x55, 0x80, 0xf1, 0x4f, 0xfd, 0x9d, 0xe9, 0xe9, 0xad, 0x75, 0x36, 0x9b, 0xca, 0x24, 0xd9, 0x4c,
	0x9c, 0xbf, 0xc9, 0x66, 0xd3, 0xc9, 0xf6, 0x6c, 0xb2, 0xb3, 0x7f, 0x81, 0xea, 0x6a, 0x57, 0x6f,
	0x65, 0xea, 0x6f, 0x5c, 0xd5, 0xbb, 0x33, 0x89, 0x10, 0xb8, 0x5d, 0xb7, 0xaa, 0xbc, 0xe5, 0xb2,
	0x0b, 0xdb, 0x35, 0xd3, 0xfd, 0x82, 0x78, 0x43, 0x20, 0xf1, 0x1a, 0xc1, 0x13, 0x7f, 0x42, 0x08,
	0x82, 0x84, 0x84, 0xc4, 0x03, 0x2f, 0x3c, 0x80, 0x04, 0x12, 0x0f, 0x48, 0x28, 0xef, 0xf0, 0xce,
	0x03, 0x79, 0x01, 0x41, 0x10, 0x12, 0xe8, 0x9c, 0x6b, 0xbb, 0xaa, 0x97, 0x45, 0x88, 0x7b, 0x5d,
	0xad, 0x19, 0xd2, 0x4f, 0xd3, 0x1e, 0xdb, 0x9f, 0x8f, 0x8f, 0xcf, 0x3d, 0xf7, 0xdc, 0x73, 0xce,
	0x2d, 0x78, 0x6e, 0xc6, 0x02, 0x16, 0x39, 0x09, 0x9b, 0x1c, 0xac, 0xa2, 0x30, 0x09, 0x8d, 0x57,
	0x67, 0x5e, 0x32, 0x5f, 0x9f, 0x1d, 0xb8, 0xe1, 0xf2, 0x60, 0xfe, 0x9a, 0xbb, 0xb8, 0x1b, 0x2d,
	0x5f, 0x5d, 0xdc, 0x3d, 0x98, 0x85, 0x33, 0xd7, 0xf5, 0x82, 0x24, 0x0a, 0x0f, 0xa6, 0xce, 0x82,
	0xcd, 0xc2, 0x03, 0x27, 0x4e, 0xf8, 0x2d, 0xe6, 0x03, 0xa8, 0x5a, 0xe7, 0xab, 0x68, 0x94, 0x2c,
	0x13, 0xc3, 0x02, 0xe5, 0x61, 0x43, 0xb9, 0xad, 0xde, 0xb9, 0x71, 0xf8, 0xfa, 0xc1, 0xff, 0x19,
	0x75, 0x80, 0x1c, 0x5b, 0x39, 0x37, 0x01, 0xaa, 0xa3, 0xc4, 0x89, 0xf0, 0x10, 0xff, 0x3e, 0x66,
	0xae, 0x8f, 0x78, 0xb3, 0x06, 0x95, 0x23, 0x67, 0x82, 0x87, 0xf8, 0x67, 0x6b, 0xee, 0x04, 0xc7,
	0x1e, 0x5d, 0x81, 0x7f, 0x8e, 0x2f, 0x56, 0xcc, 0xf4, 0xa1, 0xd2, 0x0a, 0x97, 0x4b, 0x16, 0x24,
	0x46, 0x0f, 0x4a, 0x23, 0xdf, 0x89, 0xe7, 0x12, 0xf2, 0xb4, 0xc3, 0xf0, 0xae, 0x5d, 0x8a, 0x91,
	0x62, 0x18, 0xa0, 0x8f, 0xd9, 0x79, 0xd2, 0x50, 0x6f, 0xab, 0x77, 0x6a, 0xb6, 0x9e, 0xb0, 0xf3,
	0xc4, 0xdc, 0x03, 0xb0, 0x59, 0xb2, 0x8e, 0x02, 0x92, 0x6e, 0x0f, 0xa0, 0x13, 0x5b, 0xe7, 0xab,
	0x30, 0x4a, 0xd8, 0x04, 0xa5, 0xea, 0xb3, 0x27, 0x9d, 0x09, 0x0b, 0x12, 0xb3, 0x0c, 0x7a, 0x3f,
	0x9c, 0x30, 0xf3, 0x97, 0x5f, 0x01, 0x1d, 0x5f, 0xca, 0x18, 0x80, 0x9e, 0x5c, 0xac, 0x18, 0x89,
	0xb6, 0x7f, 0xf8, 0x96, 0x80, 0x68, 0xc8, 0xc3, 0x37, 0xb6, 0x09, 0x64, 0x8c, 0xa1, 0x72, 0xe6,
	0x4c, 0xd8, 0xf9, 0x2a, 0x6a, 0x68, 0xb7, 0x95, 0x3b, 0x37, 0x0e, 0xdf, 0x14, 0x60, 0x1e, 0x39,
	0x13, 0xfa, 0x02, 0x19, 0xca, 0xf8, 0x59, 0x80, 0x33, 0x2f, 0x70, 0xa2, 0x0b, 0x02, 0x97, 0x09,
	0xfc, 0x8e, 0x08, 0x98, 0x20, 0xc4, 0xde, 0x02, 0x1a, 0xef, 0x43, 0xd5, 0x75, 0x7c, 0x9f, 0xe0,
	0x35, 0x82, 0x8b, 0x68, 0xa2, 0xe5, 0xf8, 0x3e, 0xa1, 0x73, 0x18, 0x82, 0xf1, 0xdf, 0x38, 0x59,
	0x26, 0x8d, 0x17, 0x84, 0xc1, 0x99, 0x55, 0xdb, 0x39, 0xcc, 0xf8, 0x2e, 0xd4, 0xbc, 0x60, 0xc2,
	0xce, 0x49, 0x64, 0x93, 0xc8, 0x6f, 0x0b, 0x90, 0x3b, 0xc8, 0x20, 0x99, 0x37, 0x38, 0xc3, 0x85,
	0xbd, 0x05, 0xbb, 0x78, 0xec, 0xf8, 0x6b, 0x46, 0xf8, 0x2f, 0x12, 0xfe, 0xa7, 0x05, 0xf0, 0xf7,
	0xd9, 0xc5, 0x7b, 0x88, 0xa1, 0x27, 0x5c, 0x82, 0xe2, 0x0b, 0xac, 0x9c, 0x88, 0x05, 0xf4, 0x84,
	0x97, 0x85, 0x5f, 0x60, 0x88, 0x0c, 0xfe, 0x02, 0x39, 0x0e, 0x5f, 0x20, 0x66, 0x3e, 0x73, 0x93,
	0x30, 0x22, 0xfc, 0x81, 0xf0, 0x0b, 0x8c, 0x52, 0x0c, 0x7f, 0x81, 0x6d, 0x28, 0xbe, 0x40, 0xec,
	0x7b, 0x2e, 0x57, 0xd1, 0x37, 0x84, 0x5f, 0x60, 0x84, 0x0c, 0xfe, 0x02, 0x39, 0x0e, 0xcd, 0x26,
	0x4e, 0x1c, 0x2e, 0xfc, 0xa1, 0xb0, 0xd9, 0x64, 0x9e, 0xcb, 0xce, 0x61, 0x86, 0x07, 0xfb, 0x38,
	0x4a, 0x9d, 0x38, 0x66, 0x51, 0x42, 0xf8, 0x6f, 0x12, 0xbe, 0x29, 0x80, 0xc7, 0x41, 0xdf, 0x24,
	0x10, 0x3d, 0xe4, 0x43, 0x60, 0xd4, 0xcf, 0x3a, 0x1f, 0xb1, 0xf7, 0x84, 0xf5, 0x73, 0x9a, 0x0f,
	0xd8, 0x0d, 0x0e, 0xf5, 0x33, 0x5d, 0x07, 0x2e, 0x79, 0xae, 0x4f, 0x09, 0xeb, 0xa7, 0xbd, 0x0e,
	0x5c, 0xf2, 0x5c, 0x39, 0xcc, 0xe8, 0x43, 0xc9, 0x43, 0x47, 0xd9, 0x78, 0x89, 0xa8, 0xf7, 0x44,
	0x86, 0x14, 0xde, 0x6f, 0x73, 0x8c, 0x31, 0x85, 0x9b, 0x5e, 0x90, 0xb0, 0x68, 0xea, 0xb8, 0x8c,
	0xa4, 0xfd, 0x3c, 0x71, 0x7f, 0x46, 0x68, 0xa8, 0xa6, 0x1c, 0x12, 0xf9, 0x32, 0x16, 0xfd, 0x63,
	0x9c, 0x44, 0x6b, 0x37, 0xa1, 0x87, 0xdc, 0x15, 0xf6, 0x8f, 0x23, 0x82, 0xd0, 0x13, 0xb6, 0x80,
	0xf8, 0x2d, 0x9d, 0x28, 0x72, 0x2e, 0x88, 0xfe, 0x8e, 0xf0, 0xb7, 0x6c, 0x22, 0x83, 0xe0, 0x1b,
	0x1c, 0x7e, 0xcb, 0x33, 0x27, 0xf6, 0x5c, 0xdf, 0x4b, 0x1a, 0x25, 0xe1, 0x6f, 0x79, 0x84, 0x88,
	0xae, 0x97, 0xd8, 0x39, 0x0c, 0xbd, 0x80, 0x1b, 0x2e, 0x57, 0x61, 0xec, 0x25, 0x0c, 0xe1, 0xcf,
	0x09, 0x7b, 0x81, 0x56, 0x86, 0xc1, 0x07, 0x5c, 0x82, 0xa6, 0xd3, 0xdd, 0x84, 0xb9, 0x7e, 0x43,
	0x95, 0x99, 0xee, 0x30, 0x94, 0xb0, 0x33, 0x54, 0x4a, 0xa5, 0x59, 0x43, 0x97, 0xa1, 0xd2, 0xa4,
	0x91, 0xa1, 0xf0, 0x2b, 0x9e, 0xf9, 0xa1, 0xbb, 0x20, 0x6e, 0x45, 0xf8, 0x2b, 0x1e, 0x21, 0x83,
	0xc8, 0x1b, 0x1c, 0x4d, 0xd0, 0x91, 0x13, 0xb8, 0x73, 0x82, 0x57, 0xc5, 0x27, 0x68, 0x82, 0x10,
	0x7d, 0x0b, 0x88, 0x78, 0xd7, 0x89, 0x99, 0xeb, 0x3b, 0xeb, 0x98, 0x35, 0x40, 0x18, 0xdf, 0x72,
	0x62, 0xd6, 0x22, 0x88, 0xbd, 0x05, 0x44, 0x7d, 0xbb, 0x73, 0x27, 0x98, 0x78, 0x51, 0xe3, 0x86,
	0xb0, 0xbe, 0xd3, 0x28, 0xd0, 0xce, 0x50, 0x14, 0x55, 0xcc, 0x9d, 0x80, 0x06, 0xcd, 0x9e, 0x78,
	0x54, 0x91, 0x46, 0x94, 0x76, 0x0e, 0x23, 0x6d, 0x84, 0xcb, 0x65, 0xaa, 0x8d, 0x9b, 0xe2, 0xda,
	0x08, 0x97, 0xcb, 0x5c, 0x1b, 0x39, 0x90, 0xb4, 0xc1, 0x43, 0xd7, 0xc6, 0xbe, 0xb8, 0x36, 0x38,
	0xc1, 0xce, 0x50, 0xa8, 0x0d, 0xb4, 0x6d, 0xb2, 0x8f, 0xba, 0xb0, 0x36, 0xb2, 0x08, 0xdc, 0xce,
	0x61, 0x68, 0xd6, 0x13, 0x36, 0x65, 0x3c, 0xc8, 0x7a, 0x5e, 0xd8, 0xac, 0x8f, 0x91, 0xc1, 0xcd,
	0x3a, 0xc7, 0x51, 0xfc, 0xe6, 0xfb, 0xde, 0x2a, 0xf6, 0xe2, 0x86, 0x21, 0x1e, 0xbf, 0xa5, 0x08,
	0x3b, 0x87, 0xa1, 0xd0, 0x6c, 0xb9, 0x4a, 0x2e, 0x48, 0xe8, 0x8f, 0x09, 0x0b, 0x6d, 0x21, 0x83,
	0x0b, 0x9d, 0xe3, 0x70, 0x12, 0x9b, 0x7a, 0xcc, 0x9f, 0x34, 0x3e, 0x2e, 0x3c, 0x89, 0xb5, 0xf1,
	0x7e, 0x9b, 0x63, 0x50, 0x56, 0xfa, 0xc3, 0xf7, 0xe2, 0xa4, 0xf1, 0xa2, 0xb0, 0xac, 0xc4, 0xec,
	0x7a, 0x71, 0x62, 0x6f, 0x70, 0xc6, 0x7d, 0xd0, 0xa7, 0x9e, 0xcf, 0x1a, 0x9f, 0x20, 0xac, 0xd0,
	0xd2, 0xc8, 0xf3, 0x99, 0x4d, 0x10, 0x34, 0xdc, 0x69, 0xc8, 0xed, 0xa0, 0x21, 0x6c, 0xb8, 0xed,
	0x90, 0x5b, 0x41, 0x86, 0xca, 0x82, 0x0d, 0xf2, 0xf1, 0x9f, 0x94, 0x0a, 0x36, 0xc8, 0xc9, 0xe7,
	0x30, 0x12, 0x77, 0x1d, 0xd0, 0xc4, 0x77, 0x4b, 0x5c, 0xdc, 0x75, 0x40, 0xf3, 0x5e, 0x86, 0x42,
	0xea, 0x8c, 0x05, 0x24, 0xed, 0xa7, 0x85, 0xa9, 0x27, 0x2c, 0xe0, 0x33, 0x52, 0x8a, 0x32, 0x1e,
	0x40, 0x79, 0x16, 0x92, 0x66, 0x3f, 0x43, 0xd0, 0x37, 0x44, 0xa0, 0x21, 0x29, 0x36, 0x05, 0x21,
	0xd2, 0x9b, 0x12, 0xf2, 0xb3, 0xc2, 0xc8, 0xce, 0x94, 0x23, 0x39, 0x08, 0x1d, 0xa3, 0xb7, 0xc4,
	0x65, 0x6f, 0xbc, 0x62, 0x6e, 0xe3, 0xb6, 0xb0, 0x63, 0xec, 0x10, 0x64, 0xb4, 0x62, 0xae, 0xbd,
	0x05, 0x24, 0x3c, 0x7d, 0x3b, 0x92, 0xfa, 0x73, 0xe2, 0x78, 0x32, 0x05, 0x3e, 0xc9, 0x6d, 0x80,
	0x84, 0x8f, 0x59, 0xba, 0x6c, 0x6f, 0x7c, 0x41, 0x1c, 0x9f, 0xaf, 0xfd, 0xed, 0x2d, 0xa0, 0xf1,
	0xf3, 0x70, 0xc3, 0x77, 0xce, 0x98, 0xcf, 0x78, 0x60, 0xf1, 0x25, 0xe2, 0x7f, 0x5b, 0x80, 0xdf,
	0xe5, 0x14, 0x92, 0x7f, 0x1b, 0x89, 0xa6, 0xb7, 0x74, 0x56, 0x34, 0xdf, 0x7d, 0x59, 0xd8, 0xf4,
	0x7a, 0xce, 0x8a, 0xa6, 0xbb, 0x0c, 0x85, 0xe3, 0x2f, 0x60, 0x4f, 0x78, 0x58, 0x7e, 0x47, 0x78,
	0xfc, 0x65, 0x29, 0x10, 0x3b, 0x87, 0xa1, 0xb8, 0x2b, 0xc7, 0x5d, 0x38, 0x33, 0xd6, 0xf8, 0x8a,
	0xb0, 0xb8, 0x43, 0x4e, 0xb0, 0x33, 0x14, 0x7a, 0xcb, 0xc8, 0x09, 0x66, 0x8c, 0x94, 0xfc, 0x55,
	0x61, 0x6f, 0x69, 0x23, 0x83, 0x7b, 0xf6, 0x1c, 0x87, 0x16, 0x12, 0x51, 0x9a, 0x87, 0xe0, 0xaf,
	0x08, 0x5b, 0xc8, 0x26, 0x57, 0x64, 0x6f, 0x01, 0x69, 0x15, 0x41, 0x4b, 0x5c, 0xc2, 0x7f, 0x4d,
	0x7c, 0x15, 0x41, 0x10, 0x8e, 0xdf, 0x00, 0x69, 0x55, 0xcb, 0x02, 0x6e, 0x7d, 0x5f, 0x17, 0x5f,
	0xd5, 0xb2, 0x80, 0x9b, 0x5e, 0x0e, 0xc3, 0x49, 0x84, 0x06, 0xfc, 0xab, 0xc2, 0x93, 0x08, 0x0d,
	0x75, 0x3d, 0x1b, 0xe4, 0xf1, 0x13, 0x2f, 0x49, 0x23, 0xd9, 0xd7, 0xc4, 0x95, 0x40, 0x90, 0x54,
	0x09, 0x39, 0x10, 0x95, 0x80, 0x56, 0x4d, 0xf2, 0x7e, 0x4b, 0x58, 0x09, 0x38, 0x42, 0x48, 0xe6,
	0x1c, 0x96, 0x2d, 0xed, 0xb7, 0x64, 0x7f, 0x5d, 0x6a, 0x69, 0xbf, 0x25, 0xff, 0x87, 0xc0, 0x68,
	0xe2, 0x94, 0xc8, 0xa1, 0x97, 0x78, 0x43, 0xd8, 0xc4, 0x29, 0x35, 0x44, 0x6f, 0xb1, 0xc1, 0xa5,
	0xab, 0x36, 0x8c, 0x18, 0x67, 0x51, 0xb8, 0x5e, 0x35, 0xde, 0x94, 0x59, 0xb5, 0x21, 0xe6, 0x04,
	0x31, 0xf6, 0x25, 0x28, 0x7e, 0x63, 0x27, 0x8e, 0xbd, 0x19, 0x1f, 0x47, 0x6f, 0x09, 0x7f, 0xe3,
	0x26, 0x41, 0xf8, 0x37, 0xde, 0x00, 0x71, 0x66, 0x0b, 0xcf, 0x3e, 0x60, 0x6e, 0xd2, 0x78, 0x5b,
	0x78, 0x66, 0x1b, 0x10, 0xc0, 0x4e, 0x41, 0x3c, 0x7a, 0x9e, 0xb2, 0x28, 0x62, 0x93, 0xc6, 0xb7,
	0x25, 0xa2, 0x67, 0x8e, 0xb0, 0x73, 0x98, 0xf9, 0x83, 0x7d, 0xd0, 0x29, 0x63, 0xbe, 0xa3, 0x4c,
	0xf0, 0xf5, 0x22, 0x36, 0x5f, 0xc4, 0x3e, 0x93, 0x2b, 0xa0, 0x5d, 0x2e, 0x54, 0x76, 0x96, 0x1d,
	0xdf, 0xcd, 0x42, 0xe0, 0xd9, 0x89, 0x81, 0x77, 0x18, 0xa4, 0xee, 0x3e, 0x8a, 0xbc, 0x0e, 0xa0,
	0xae, 0x3c, 0x80, 0xda, 0x71, 0xcc, 0x73, 0x85, 0xa1, 0xc9, 0xe5, 0x99, 0xfd, 0x5e, 0xc1, 0x33,
	0xbb, 0xf9, 0xa7, 0x1a, 0xe8, 0xe8, 0x80, 0x77, 0x35, 0x5b, 0x16, 0x9d, 0x48, 0xde, 0xd9, 0x94,
	0xb3, 0xcb, 0xa4, 0x48, 0xf1, 0xe9, 0x0b, 0xb3, 0x0c, 0x3a, 0x06, 0x9a, 0xe6, 0x7f, 0x28, 0x00,
	0x9b, 0xc5, 0xbd, 0xd1, 0x05, 0xbd, 0xef, 0x2c, 0xf1, 0x2b, 0xca, 0x55, 0x7b, 0xf4, 0xc0, 0x59,
	0x32, 0xb4, 0x89, 0xa1, 0x93, 0xcc, 0xa9, 0x30, 0x2f, 0x59, 0xc5, 0xd0, 0x57, 0x4e, 0x32, 0x37,
	0x06, 0x50, 0xb6, 0x82, 0xc9, 0x30, 0x8c, 0xd3, 0x52, 0xba, 0x70, 0xe7, 0x40, 0x99, 0x11, 0xc6,
	0xdc, 0x87, 0xbd, 0xed, 0xa8, 0xd8, 0x34, 0x41, 0xc7, 0xf3, 0xc6, 0x2d, 0xa8, 0x26, 0xe1, 0x82,
	0x05, 0xab, 0x30, 0x26, 0x5d, 0x68, 0x76, 0x7e, 0x4c, 0xad, 0x02, 0xed, 0x30, 0x3c, 0x7c, 0x56,
	0x4c, 0x7e, 0x37, 0x0d, 0x08, 0xbb, 0x09, 0x66, 0x77, 0x56, 0xfb, 0xda, 0x71, 0xbf, 0xc4, 0xb3,
	0x1d, 0x84, 0xef, 0xa6, 0xd5, 0xe3, 0xba, 0x44, 0xf5, 0xcc, 0x97, 0xa8, 0xae, 0xa4, 0x62, 0x7c,
	0x5d, 0x07, 0xbb, 0xaa, 0x3a, 0xd8, 0xce, 0x96, 0x97, 0xd7, 0x05, 0xb6, 0x9f, 0xe4, 0x02, 0xdb,
	0xce, 0x9a, 0x8f, 0x9e, 0x99, 0xca, 0x5d, 0xd1, 0x5d, 0x52, 0xd7, 0x95, 0xc0, 0x0f, 0x25, 0x59,
	0x76, 0xd9, 0xdd, 0x79, 0x85, 0x2d, 0x69, 0xbb, 0xac, 0x66, 0x5e, 0x49, 0x93, 0xea, 0x75, 0xc9,
	0xf4, 0xaa, 0x4a, 0xa6, 0x3b, 0xeb, 0x05, 0xbe, 0xce, 0x26, 0xfe, 0x4f, 0xd9, 0xc4, 0x2b, 0xe9,
	0x92, 0xde, 0x59, 0xca, 0x72, 0x97, 0xed, 0xd7, 0x85, 0xd6, 0x93, 0x77, 0xd6, 0xcb, 0xbd, 0xe3,
	0x9e, 0xdf, 0xab, 0xc9, 0x09, 0x5f, 0x45, 0x27, 0xfa, 0xff, 0x93, 0x92, 0xfb, 0xce, 0xba, 0xe9,
	0xaf, 0xcb, 0xf9, 0x57, 0x5e, 0xce, 0xdf, 0x71, 0x43, 0xfd, 0x6e, 0x5a, 0x05, 0xfe, 0x5c, 0x05,
	0xd8, 0xa8, 0xc8, 0xe8, 0x80, 0xd6, 0x9d, 0xc7, 0x0d, 0xe5, 0xb6, 0x26, 0xb3, 0xc9, 0x4e, 0xf3,
	0xe7, 0xb1, 0x31, 0x80, 0xf2, 0x38, 0x5c, 0x0c, 0xc3, 0x38, 0x4d, 0x04, 0x8b, 0x27, 0xba, 0x13,
	0xc2, 0xa0, 0x6c, 0xe3, 0x70, 0x21, 0x9b, 0x36, 0xd7, 0x92, 0x70, 0x81, 0x28, 0x7b, 0x1e, 0x37,
	0x74, 0xc9, 0xd7, 0x8c, 0xe6, 0xb1, 0xf9, 0x9b, 0x0a, 0x6d, 0x1b, 0xb4, 0xd2, 0x39, 0xa6, 0x1d,
	0x85, 0xcb, 0xb4, 0xf4, 0x20, 0x28, 0xe2, 0xa1, 0xad, 0x4f, 0xa3, 0x70, 0x69, 0x9c, 0x80, 0x3a,
	0x0e, 0xe5, 0x74, 0x77, 0x68, 0xab, 0x49, 0x98, 0x49, 0x38, 0x4a, 0xbb, 0xaa, 0x9e, 0x42, 0x09,
	0x7f, 0x45, 0x81, 0x6a, 0x96, 0xf0, 0x36, 0x46, 0x50, 0x25, 0xaf, 0x33, 0x4c, 0xeb, 0x16, 0x12,
	0xdf, 0xba, 0xfa, 0x38, 0x05, 0x19, 0x06, 0xe8, 0xf7, 0xbd, 0x60, 0x42, 0xc2, 0xd6, 0x6c, 0x7d,
	0xe1, 0x05, 0x13, 0xe3, 0x05, 0x28, 0xd1, 0x83, 0xc8, 0xa2, 0x6a, 0x76, 0x89, 0x2e, 0x36, 0xff,
	0x44, 0x05, 0xd8, 0x64, 0xc8, 0xb3, 0x3d, 0xa7, 0x8a, 0xdc, 0x9e, 0x53, 0xa3, 0x07, 0xa5, 0xc1,
	0xaa, 0x80, 0xb1, 0x50, 0x0a, 0x91, 0x82, 0x9a, 0x1f, 0xac, 0x64, 0x47, 0x82, 0x1a, 0xae, 0xf0,
	0xf5, 0x1e, 0xa5, 0xc5, 0x0f, 0xf1, 0xd7, 0xbb, 0x30, 0xff, 0x5d, 0x81, 0x5a, 0x9e, 0xf8, 0xc7,
	0x91, 0xdf, 0x3d, 0x8b, 0x1c, 0x97, 0xc9, 0x7e, 0xbf, 0xb2, 0x4f, 0x18, 0xb4, 0xda, 0xae, 0x17,
	0x27, 0x0d, 0x55, 0x78, 0xbc, 0x92, 0xff, 0xd7, 0x29, 0x79, 0x36, 0x80, 0xb2, 0xcd, 0xa5, 0x93,
	0x2d, 0xc0, 0x45, 0x84, 0x31, 0xff, 0x4d, 0x01, 0xd8, 0x14, 0x26, 0xb6, 0xfc, 0x9e, 0x52, 0xa8,
	0xdf, 0x53, 0x0b, 0xf0, 0x7b, 0x7d, 0x28, 0xd1, 0xaa, 0x35, 0x7d, 0x75, 0x89, 0x24, 0x0f, 0xad,
	0x77, 0xcd, 0xdf, 0xd0, 0xa0, 0x9a, 0x95, 0x4d, 0x50, 0xce, 0xf6, 0x3a, 0x90, 0xdd, 0xa0, 0xad,
	0x4d, 0xd7, 0x01, 0x59, 0x10, 0x2d, 0xf7, 0xa4, 0xe7, 0x0e, 0x9f, 0x30, 0x68, 0x41, 0xcd, 0x68,
	0x16, 0x37, 0x34, 0x39, 0x8f, 0xaf, 0x3b, 0xd1, 0x2c, 0x46, 0x0f, 0x95, 0x65, 0xbd, 0x25, 0xc6,
	0x0e, 0xf7, 0x50, 0x79, 0xd2, 0x1c, 0xcd, 0x92, 0xbf, 0x72, 0x49, 0xd6, 0x2c, 0x09, 0x63, 0xfe,
	0x85, 0x0a, 0xb0, 0xa9, 0x3b, 0xa1, 0x06, 0xf0, 0x48, 0xd6, 0x28, 0x75, 0xd7, 0x89, 0x8b, 0x18,
	0x90, 0x5c, 0x9d, 0x34, 0x20, 0x7b, 0x50, 0x6a, 0x85, 0x7e, 0x18, 0xc8, 0x8e, 0xc7, 0x92, 0x8b,
	0x14, 0x94, 0xed, 0x28, 0x9c, 0x5c, 0x48, 0x4c, 0xee, 0xdc, 0x59, 0x9c, 0x85, 0x93, 0x0b, 0xae,
	0xc4, 0xbc, 0x5c, 0x55, 0x8c, 0x12, 0x0f, 0x37, 0x4a, 0x44, 0x74, 0xda, 0x5a, 0x20, 0x2e, 0x28,
	0x86, 0xcd, 0x05, 0x29, 0xf1, 0x70, 0x27, 0x4a, 0xfc, 0x1b, 0x95, 0x5a, 0x14, 0xf2, 0xe2, 0x19,
	0xd2, 0xc7, 0x59, 0xd7, 0x81, 0x8c, 0xf9, 0x50, 0x68, 0xbc, 0x99, 0x6d, 0xd4, 0xc2, 0x66, 0x1b,
	0xcb, 0x4f, 0xe4, 0x7d, 0x05, 0xf3, 0x93, 0x78, 0x6b, 0xb6, 0xd1, 0x8b, 0x99, 0x6d, 0x7e, 0xa0,
	0x40, 0x2d, 0x2f, 0xe7, 0xe1, 0x67, 0xa7, 0x03, 0xd9, 0x61, 0x5d, 0xa2, 0x05, 0x81, 0x31, 0x40,
	0xfb, 0xf6, 0xb3, 0xd6, 0x0d, 0xa9, 0x22, 0xba, 0xee, 0x3a, 0xbe, 0x6f, 0x2e, 0xa0, 0x9a, 0x2d,
	0x3a, 0x8c, 0x7d, 0x50, 0x3b, 0x13, 0x12, 0xb4, 0x66, 0xab, 0xde, 0x24, 0xef, 0x3d, 0x51, 0x0b,
	0xea, 0x3d, 0x31, 0xff, 0x50, 0xd9, 0x38, 0xe6, 0x4b, 0x4e, 0x5a, 0x29, 0xca, 0x49, 0x77, 0x40,
	0xb3, 0xfc, 0x44, 0xc2, 0xd0, 0xf8, 0x14, 0xc7, 0xfc, 0xc4, 0xfc, 0x45, 0xa8, 0xe5, 0x05, 0x4e,
	0xe3, 0x14, 0x6a, 0x23, 0xb6, 0xf4, 0x68, 0xec, 0xc9, 0x3a, 0x97, 0x5a, 0x9c, 0x91, 0x8c, 0x5b,
	0x50, 0xed, 0x2c, 0x57, 0xbe, 0xe7, 0x7a, 0x5c, 0xe6, 0xaa, 0x5d, 0xf5, 0xd2, 0x63, 0xf3, 0x6f,
	0x55, 0x28, 0x51, 0x71, 0x11, 0x83, 0x82, 0xbe, 0xb3, 0x64, 0xd9, 0xaa, 0x4f, 0x22, 0x28, 0x08,
	0x10, 0x93, 0x8f, 0x6e, 0xb5, 0x88, 0xd1, 0xdd, 0x03, 0x6d, 0xec, 0xcc, 0x52, 0xaf, 0x26, 0xd5,
	0x48, 0xa3, 0x25, 0xce, 0xcc, 0x78, 0x94, 0xff, 0x82, 0x4b, 0x3a, 0x1e, 0xa5, 0xb3, 0x16, 0x59,
	0xa3, 0x81, 0xf9, 0x9f, 0x0a, 0xd4, 0xf2, 0x6a, 0xad, 0xf1, 0x00, 0x2a, 0x83, 0x15, 0x0b, 0xbc,
	0x60, 0x26, 0x6b, 0x7d, 0x95, 0x90, 0x73, 0x8c, 0xee, 0xa5, 0x49, 0x57, 0xbc, 0x40, 0xcd, 0x67,
	0xdd, 0x07, 0x50, 0x69, 0xf9, 0x61, 0x8c, 0x02, 0x4a, 0xce, 0xbb, 0x15, 0x97, 0x73, 0xcc, 0x3f,
	0x28, 0x81, 0xde, 0xf6, 0x7c, 0x66, 0x3c, 0x00, 0xed, 0x38, 0x74, 0xd3, 0x3e, 0x1f, 0x69, 0x0d,
	0x6b, 0x93, 0xd0, 0x45, 0x71, 0xd3, 0x12, 0x83, 0xb4, 0x3e, 0xb3, 0x0a, 0x45, 0xd6, 0x28, 0xa8,
	0x16, 0xd2, 0x28, 0x48, 0x9e, 0xd8, 0xf5, 0x65, 0xa6, 0x0d, 0xaa, 0xf1, 0x96, 0xa8, 0xf7, 0x03,
	0x07, 0xe5, 0xc8, 0x0d, 0x57, 0xd9, 0xb4, 0x21, 0x22, 0x1d, 0xdd, 0x6f, 0x97, 0x62, 0xfc, 0xc7,
	0x78, 0x1f, 0x2a, 0xbc, 0xec, 0x19, 0x37, 0x4a, 0x24, 0xa0, 0x64, 0xe1, 0xb4, 0x92, 0x16, 0x4e,
	0x8d, 0x87, 0x00, 0xa7, 0x41, 0xc4, 0xe2, 0xd0, 0x7f, 0xcc, 0x26, 0x8d, 0xb2, 0xa4, 0x0b, 0x81,
	0x75, 0xce, 0x32, 0xbe, 0x07, 0xd5, 0xd4, 0x0e, 0xe2, 0x46, 0x85, 0xb8, 0xd2, 0xa6, 0x54, 0x4d,
	0x07, 0x6b, 0x6c, 0xfe, 0x9a, 0x06, 0x95, 0xb4, 0x69, 0x81, 0x16, 0x2e, 0xa1, 0xf4, 0x14, 0xaa,
	0x4d, 0x43, 0xca, 0x00, 0x75, 0x02, 0x2f, 0x91, 0x8e, 0xe9, 0xbc, 0x80, 0x87, 0x49, 0xad, 0x30,
	0x98, 0x34, 0x34, 0x49, 0x47, 0xea, 0x86, 0xc1, 0x04, 0x61, 0xc3, 0x30, 0x46, 0xb7, 0x27, 0x27,
	0xd9, 0x2a, 0x8c, 0x13, 0x63, 0x98, 0x86, 0x87, 0xa5, 0x02, 0xda, 0x04, 0x79, 0x8c, 0xf8, 0x5b,
	0x1a, 0x54, 0xb3, 0x6e, 0x0f, 0xc4, 0xdb, 0xcc, 0x7d, 0x9c, 0x7e, 0x11, 0xb9, 0xb6, 0x19, 0x3d,
	0x62, 0xee, 0xe3, 0x82, 0xc7, 0xfa, 0x20, 0x9d, 0xe1, 0x34, 0xf9, 0x4e, 0x11, 0x3e, 0xcb, 0x0d,
	0xf3, 0x70, 0xbb, 0x20, 0x7d, 0x66, 0x2e, 0xb8, 0x54, 0x9c, 0x0b, 0x36, 0xff, 0x48, 0x81, 0x4a,
	0xda, 0x38, 0x93, 0x6b, 0x40, 0x29, 0x5a, 0x03, 0x6a, 0x61, 0x16, 0xf5, 0x4b, 0x2a, 0xb7, 0x28,
	0x7c, 0x08, 0xe5, 0x3d, 0xd7, 0x81, 0x2b, 0xbd, 0xfa, 0x9d, 0xae, 0x03, 0x17, 0x63, 0xfa, 0xa1,
	0x13, 0x39, 0xcb, 0x58, 0x36, 0xf7, 0x59, 0x5e, 0x11, 0xc6, 0x78, 0x0f, 0x2a, 0x36, 0x8b, 0xd7,
	0x7c, 0xd1, 0x21, 0x6f, 0xf2, 0x95, 0x88, 0xc3, 0xcc, 0xef, 0x6b, 0x50, 0x49, 0x7b, 0x87, 0x9e,
	0xea, 0xb4, 0xd4, 0x26, 0xdd, 0xa3, 0x15, 0x93, 0xee, 0xe9, 0x41, 0x09, 0x67, 0x29, 0x99, 0x0c,
	0x3f, 0xcd, 0x72, 0xa5, 0x18, 0x29, 0xc5, 0xe7, 0x66, 0x7e, 0x47, 0x81, 0x32, 0xef, 0xbf, 0x32,
	0x4e, 0x40, 0x3d, 0x09, 0x65, 0x63, 0x7e, 0x75, 0x16, 0x16, 0xbf, 0x76, 0xfb, 0x33, 0x05, 0x4a,
	0x9d, 0xb4, 0x97, 0xab, 0x82, 0xde, 0xb3, 0x00, 0xe3, 0xa9, 0x04, 0x9c, 0x63, 0x18, 0x5b, 0x0e,
	0xb9, 0x96, 0xba, 0xd5, 0x0e, 0x68, 0x83, 0xb3, 0x0f, 0x64, 0x33, 0x18, 0x5a, 0x78, 0xf6, 0x81,
	0xf9, 0xab, 0x1a, 0x94, 0x79, 0xf7, 0x18, 0x2a, 0xb8, 0x33, 0x95, 0x95, 0x5b, 0xf5, 0xa6, 0x4f,
	0xf1, 0xdc, 0x5e, 0xfc, 0xf4, 0x41, 0x39, 0x90, 0x98, 0x49, 0xd8, 0x3b, 0x87, 0x31, 0x3f, 0x66,
	0xe6, 0x8f, 0x14, 0x80, 0x4d, 0x53, 0x5c, 0x51, 0x25, 0x95, 0xa7, 0xb8, 0xbe, 0x68, 0xfe, 0xa5,
	0x0a, 0xb5, 0xbc, 0x51, 0xaf, 0xa0, 0xdf, 0x2d, 0xcd, 0x13, 0x5d, 0x8b, 0x62, 0x12, 0x5d, 0x0b,
	0xf4, 0x92, 0x24, 0xa4, 0xac, 0x11, 0x96, 0xa8, 0x11, 0x31, 0x4f, 0x75, 0x2d, 0x8a, 0x49, 0x75,
	0x2d, 0xcc, 0xbf, 0x57, 0xe0, 0xe6, 0xa5, 0x76, 0x44, 0xe3, 0x14, 0xd5, 0x9a, 0xfe, 0x87, 0xec,
	0x90, 0xae, 0xe5, 0xad, 0x8d, 0x38, 0xff, 0xf6, 0x58, 0x32, 0x0f, 0x27, 0xb1, 0x44, 0xfc, 0xb1,
	0x35, 0xff, 0x2e, 0x39, 0xcc, 0x78, 0x89, 0xec, 0x3e, 0x5c, 0xae, 0x7c, 0x96, 0xf0, 0x68, 0xb1,
	0x4a, 0x2d, 0xa1, 0xe9, 0xff, 0x98, 0xff, 0xaa, 0xc0, 0xde, 0x76, 0xa7, 0x22, 0x9a, 0xe0, 0x7d,
	0x76, 0x21, 0x3b, 0x38, 0xb4, 0x05, 0xbb, 0xd8, 0x24, 0x84, 0xd5, 0x42, 0xb2, 0xea, 0xbd, 0xed,
	0x62, 0xa9, 0x8c, 0xad, 0xf0, 0x2a, 0xeb, 0x8f, 0x15, 0xb8, 0xb1, 0xd5, 0x3f, 0xb9, 0x29, 0x4c,
	0x29, 0x85, 0x14, 0xa6, 0x8a, 0x7e, 0xfb, 0xfb, 0xfc, 0xf7, 0x14, 0x24, 0x06, 0x0a, 0x77, 0x87,
	0xb4, 0xdf, 0xf4, 0x9f, 0x14, 0xa8, 0xa4, 0xdd, 0x9d, 0xf8, 0xc1, 0x7b, 0xce, 0x4a, 0x7a, 0xe9,
	0xb9, 0x74, 0x56, 0x99, 0xed, 0xa8, 0xc5, 0xd8, 0x4e, 0x91, 0x1f, 0xfb, 0x77, 0x55, 0x28, 0x0f,
	0xf2, 0x9f, 0xbc, 0xc8, 0xf2, 0xc1, 0x12, 0x6b, 0x87, 0xff, 0xde, 0xc7, 0xf2, 0x91, 0x05, 0xfe,
	0x2c, 0xc6, 0xd0, 0xb6, 0x62, 0x8c, 0xfb, 0x7c, 0xaf, 0xaf, 0x9c, 0x8b, 0x3a, 0xb4, 0x75, 0x6a,
	0xc3, 0x47, 0x98, 0x93, 0x38, 0xb2, 0x51, 0xa1, 0x3e, 0x71, 0x12, 0xc7, 0xfc, 0xbe, 0x9e, 0xa7,
	0xb8, 0x72, 0xc9, 0x95, 0x2d, 0xc9, 0x7b, 0x59, 0x46, 0x48, 0x72, 0xd1, 0x91, 0x26, 0x84, 0x9c,
	0x4d, 0x42, 0x88, 0x67, 0xac, 0x4e, 0xc4, 0xbb, 0x7e, 0xd3, 0xc4, 0x50, 0x6c, 0x05, 0x49, 0x74,
	0xb1, 0x49, 0x0d, 0x7d, 0x0f, 0x4a, 0x6d, 0xcf, 0x67, 0x59, 0x14, 0x6e, 0x49, 0x3c, 0x80, 0x38,
	0x1c, 0x5f, 0x9a, 0xe2, 0xdf, 0xb7, 0xd6, 0xb0, 0xb7, 0xfd, 0x54, 0xa3, 0x0e, 0x68, 0xba, 0xa9,
	0xc6, 0xc8, 0x8a, 0x07, 0xc0, 0xed, 0x2f, 0x55, 0x98, 0x44, 0x87, 0x17, 0xe7, 0xbc, 0xa9, 0xde,
	0x53, 0x6e, 0xfd, 0x02, 0xc0, 0x46, 0x96, 0x8f, 0x78, 0x68, 0xef, 0xf2, 0x43, 0x85, 0xf7, 0xe6,
	0x6c, 0x1e, 0x69, 0xfe, 0xb3, 0x02, 0xb5, 0xbc, 0x0d, 0x7a, 0x6b, 0xad, 0x24, 0xf9, 0xcb, 0xe3,
	0xd9, 0x5a, 0x89, 0xa2, 0x13, 0xb5, 0x88, 0xe8, 0xc4, 0xce, 0xd6, 0x70, 0x6a, 0x11, 0x6b, 0xa4,
	0xdf, 0xd3, 0xa1, 0x96, 0x77, 0x68, 0x6f, 0x72, 0x74, 0xaa, 0x74, 0x8e, 0x2e, 0x77, 0x94, 0x6a,
	0x91, 0x8e, 0x52, 0x95, 0x77, 0x94, 0x5b, 0x21, 0xad, 0x2e, 0xa9, 0xc3, 0xcb, 0x21, 0x6d, 0x49,
	0x52, 0x6b, 0xb8, 0x46, 0x27, 0x33, 0x29, 0x4b, 0x9b, 0x49, 0xb6, 0x54, 0xa9, 0x14, 0x96, 0xe7,
	0xf9, 0x07, 0x25, 0x75, 0x8c, 0xc6, 0xcf, 0x41, 0x85, 0x0f, 0xd8, 0xac, 0x94, 0x65, 0x89, 0x66,
	0xcd, 0xd3, 0x81, 0x9f, 0x39, 0x34, 0xde, 0xe0, 0x49, 0x3e, 0x67, 0xfb, 0xc4, 0x15, 0xf9, 0x1c,
	0xf3, 0x8f, 0x15, 0x80, 0x4d, 0xbf, 0x3f, 0x5a, 0x09, 0x3f, 0x92, 0xcd, 0x1a, 0x94, 0x79, 0x57,
	0xff, 0x0e, 0x72, 0x6f, 0xbf, 0xad, 0xc0, 0xde, 0xf6, 0x06, 0x82, 0xa2, 0x96, 0x40, 0xdf, 0x01,
	0x6d, 0xc4, 0x7c, 0xe9, 0x2c, 0xae, 0x16, 0x33, 0xdf, 0xfc, 0x17, 0x05, 0xaa, 0xd9, 0x1e, 0x04,
	0x5a, 0x8e, 0xcf, 0x1d, 0xe9, 0xe6, 0x25, 0xdd, 0x9d, 0x3b, 0x14, 0x2b, 0x37, 0xa3, 0x28, 0x7c,
	0x22, 0x3d, 0x53, 0x3b, 0x48, 0x29, 0xd8, 0xc9, 0x98, 0x3f, 0xd2, 0xa0, 0x96, 0xef, 0x90, 0x28,
	0x70, 0x31, 0x5e, 0xec, 0xda, 0xb4, 0x03, 0x5a, 0x37, 0x7c, 0x22, 0x1b, 0x80, 0x6a, 0x7e, 0xf8,
	0x04, 0xbf, 0xed, 0xbb, 0xde, 0x6c, 0x2e, 0xdb, 0xe6, 0xa8, 0xcf, 0xbd, 0xd9, 0x9c, 0x07, 0xec,
	0xe7, 0x12, 0x11, 0x1f, 0x97, 0x6b, 0xe9, 0x9c, 0x1b, 0x2f, 0x42, 0x99, 0xbe, 0xc3, 0x5d, 0xfa,
	0x2d, 0x87, 0xaa, 0x5d, 0xa6, 0xcd, 0x2a, 0x77, 0xb7, 0xd6, 0xd1, 0x95, 0x62, 0xd6, 0xd1, 0x3f,
	0x44, 0xff, 0x91, 0x6f, 0x08, 0x21, 0xff, 0x41, 0x47, 0xd2, 0x99, 0x60, 0xbe, 0xb3, 0xc4, 0x18,
	0x43, 0x99, 0x16, 0xbf, 0xc5, 0xac, 0x9e, 0xcb, 0xb4, 0xcf, 0xf9, 0x7f, 0x5f, 0x3c, 0xff, 0xb5,
	0x0a, 0xb0, 0xd9, 0x5c, 0x41, 0x6f, 0x45, 0x47, 0xf2, 0x6f, 0x45, 0x98, 0x62, 0xd3, 0x7d, 0x9d,
	0xac, 0x8d, 0x41, 0x2e, 0xe6, 0x48, 0x9c, 0x59, 0xf1, 0xc9, 0x3e, 0xf3, 0xf7, 0x15, 0xa8, 0xe5,
	0xbb, 0x0e, 0xb6, 0x86, 0xb2, 0x74, 0x80, 0x99, 0x0f, 0x65, 0xde, 0x34, 0xa3, 0x4a, 0x37, 0xcd,
	0xfc, 0x95, 0x0a, 0xfb, 0x97, 0x37, 0x06, 0x15, 0x99, 0x5c, 0x2b, 0xba, 0xe3, 0x74, 0xab, 0x46,
	0x28, 0xdf, 0xe3, 0x96, 0x06, 0xd7, 0x7a, 0x31, 0x05, 0x88, 0x1f, 0xaa, 0x50, 0xcd, 0x36, 0x3f,
	0x15, 0xfc, 0x8b, 0x49, 0x85, 0xb6, 0xff, 0xa4, 0x65, 0x4c, 0xad, 0xc0, 0x4e, 0x92, 0x1d, 0xb6,
	0x00, 0xfd, 0x5d, 0x6a, 0x9e, 0xc5, 0xbb, 0xa5, 0xc3, 0xdd, 0xb8, 0xa5, 0x01, 0x94, 0xf9, 0xe6,
	0x1f, 0xd9, 0xcc, 0x56, 0x99, 0x6f, 0xad, 0xda, 0x81, 0x73, 0xfa, 0x47, 0x05, 0x6a, 0xf9, 0x0e,
	0xb7, 0xcd, 0x3e, 0x0a, 0xa5, 0xc0, 0x7d, 0x14, 0x6a, 0x21, 0xfb, 0x28, 0x1e, 0xca, 0x7a, 0x77,
	0xe5, 0xdc, 0xfc, 0xb1, 0x02, 0xb5, 0x7c, 0xcb, 0xdd, 0xd3, 0xdd, 0x98, 0x37, 0x80, 0x32, 0x49,
	0x2a, 0xdd, 0x27, 0x5b, 0xe6, 0x1b, 0x0b, 0x5f, 0xfe, 0xf5, 0x0a, 0x54, 0xb3, 0x86, 0x4e, 0xe3,
	0x26, 0xd4, 0x9a, 0xb6, 0xdd, 0x7c, 0x34, 0x7e, 0x34, 0xb4, 0xea, 0x3f, 0x65, 0xec, 0x03, 0x34,
	0x47, 0xa3, 0xce, 0x49, 0x7f, 0x34, 0xee, 0x8d, 0xeb, 0x8a, 0x71, 0x03, 0x2a, 0x47, 0xcd, 0xe3,
	0x63, 0xab, 0xd5, 0xad, 0xab, 0xe9, 0x81, 0xf5, 0x70, 0x68, 0xd7, 0xb5, 0xf4, 0x80, 0x2e, 0xd3,
	0x8d, 0x3d, 0xa8, 0x1e, 0x35, 0x47, 0x9d, 0x56, 0xb7, 0x33, 0xae, 0x97, 0x10, 0x72, 0xd4, 0xe9,
	0x37, 0xed, 0x47, 0x74, 0x69, 0x19, 0x9f, 0x71, 0xd4, 0x1d, 0xb4, 0xee, 0xd3, 0xc5, 0x15, 0x3a,
	0x6d, 0x37, 0xfb, 0xad, 0x77, 0xe9, 0xb8, 0x8a, 0x37, 0xb7, 0x9a, 0xdd, 0x2e, 0x5d, 0x5c, 0xc3,
	0xb3, 0xad, 0xe6, 0xc8, 0x6a, 0x75, 0x9b, 0xa7, 0x23, 0xab, 0x0e, 0xf8, 0x9c, 0xd6, 0xbb, 0xcd,
	0xfe, 0x71, 0xc7, 0xae, 0xdf, 0xa0, 0x4b, 0xdf, 0x6d, 0xf6, 0x49, 0xd8, 0x3d, 0xba, 0x74, 0xd0,
	0xeb, 0xa5, 0x97, 0xde, 0xa4, 0x4b, 0x07, 0xbd, 0x9e, 0xd5, 0x1f, 0xd7, 0xf7, 0x8d, 0x3a, 0xec,
	0xb5, 0x06, 0xbd, 0xe1, 0x60, 0xd4, 0x19, 0x5b, 0x28, 0xd6, 0x73, 0x78, 0x33, 0xbe, 0x08, 0x3d,
	0xb5, 0x8e, 0x42, 0x1d, 0x5b, 0x6d, 0xcb, 0xa6, 0xc3, 0xe7, 0xf1, 0xa4, 0xd5, 0xed, 0x76, 0x86,
	0xa3, 0xce, 0xa8, 0x6e, 0xe0, 0x49, 0xab, 0x37, 0x1c, 0x3f, 0xa2, 0x93, 0x1f, 0xa3, 0x93, 0x0f,
	0x87, 0xfc, 0xd2, 0x17, 0x8c, 0x1a, 0x94, 0xda, 0x1d, 0xab, 0x7b, 0x5c, 0xff, 0x38, 0x5e, 0x47,
	0x7f, 0x76, 0x3b, 0xa3, 0x71, 0xfd, 0x45, 0xa3, 0x0a, 0x7a, 0xbb, 0xd3, 0xb5, 0xea, 0x9f, 0x40,
	0x51, 0xda, 0x03, 0x7e, 0x43, 0x03, 0x6f, 0x6f, 0x9f, 0xf6, 0x5b, 0xa4, 0xc5, 0x4f, 0xd2, 0xa9,
	0xd3, 0x3e, 0xa9, 0xea, 0x56, 0x76, 0x8a, 0x5e, 0xe8, 0x53, 0x78, 0xea, 0xc4, 0xea, 0xd3, 0x75,
	0x9f, 0x36, 0x00, 0xca, 0x27, 0x03, 0x22, 0x7c, 0x06, 0x1f, 0xd9, 0x39, 0xc6, 0xf7, 0x7a, 0x09,
	0xff, 0xbb, 0xd3, 0xa6, 0xff, 0xfe, 0x2c, 0x2a, 0xa0, 0xd3, 0x1b, 0x0e, 0xec, 0xf1, 0x68, 0x68,
	0xb5, 0xea, 0xb7, 0xe9, 0x98, 0x9e, 0x43, 0xe7, 0x3f, 0x87, 0xe2, 0x75, 0xfa, 0xc7, 0xd6, 0x43,
	0x52, 0xad, 0x69, 0x3c, 0x0f, 0x37, 0x3b, 0xfd, 0xb1, 0x65, 0xb7, 0x9b, 0x2d, 0x8b, 0x9e, 0xf8,
	0x79, 0xba, 0x63, 0x64, 0x3d, 0x44, 0x86, 0x75, 0x5c, 0xff, 0x02, 0x6a, 0xed, 0xbe, 0xf5, 0xe8,
	0xbd, 0x66, 0xf7, 0xd4, 0xa2, 0x9b, 0xbe, 0x68, 0x3c, 0x07, 0x37, 0xba, 0xcd, 0x23, 0xab, 0x6b,
	0xf1, 0x6f, 0xfd, 0x25, 0x14, 0xb2, 0xd7, 0x1c, 0xd2, 0xfd, 0x5f, 0x46, 0xf9, 0xfb, 0xd6, 0xfb,
	0x5c, 0xb6, 0x3b, 0x78, 0x6a, 0xd8, 0x6c, 0xdd, 0x6f, 0x9e, 0x58, 0xf5, 0xaf, 0xe0, 0xc3, 0x87,
	0x4d, 0xdb, 0xea, 0x13, 0xe7, 0x65, 0x3c, 0xb4, 0x9b, 0xfd, 0x13, 0x8b, 0x28, 0x5f, 0xc5, 0x07,
	0xdb, 0xd6, 0xf8, 0xd4, 0xe6, 0x86, 0xf6, 0x0a, 0x1e, 0x8f, 0xac, 0xae, 0xd5, 0x1a, 0xd3, 0xf1,
	0xd7, 0x50, 0x10, 0x7e, 0x3c, 0xb0, 0x09, 0x70, 0x80, 0x8f, 0x1a, 0x59, 0x7d, 0x2e, 0xc5, 0xd7,
	0x11, 0x37, 0xea, 0x76, 0x5a, 0x5c, 0xca, 0x6f, 0xa0, 0xe6, 0x49, 0x07, 0xaf, 0xd2, 0x65, 0xe3,
	0x26, 0xbf, 0xe9, 0x90, 0xb0, 0x63, 0xfb, 0xb4, 0x35, 0x26, 0x79, 0xef, 0xd2, 0xf1, 0xfb, 0x9d,
	0x71, 0x6a, 0x7b, 0xaf, 0x19, 0x06, 0xec, 0xe3, 0x99, 0xe6, 0x68, 0x64, 0xd9, 0x63, 0xba, 0xe7,
	0x9b, 0x48, 0xc0, 0xff, 0x23, 0xde, 0xb7, 0xb2, 0x2b, 0xb6, 0xee, 0x7a, 0x1d, 0x1f, 0x7e, 0x9a,
	0xdb, 0xf7, 0x3d, 0x3c, 0x24, 0x8d, 0xd1, 0x1d, 0x6f, 0xa4, 0x96, 0x87, 0x66, 0x78, 0x62, 0x0f,
	0x4e, 0x87, 0xf5, 0x37, 0xf1, 0x9b, 0x0d, 0x8e, 0xbe, 0x63, 0xb5, 0xc6, 0xf5, 0xb7, 0xb8, 0x15,
	0xb6, 0x2d, 0xdb, 0xb6, 0x8e, 0xeb, 0x6f, 0xe7, 0x56, 0x68, 0x5b, 0xc7, 0x87, 0xf5, 0x77, 0x8e,
	0xe0, 0xbb, 0x55, 0x27, 0x4e, 0x68, 0xcc, 0xfe, 0x57, 0x00, 0x00, 0x00, 0xff, 0xff, 0xa9, 0x1f,
	0x9b, 0x21, 0xd5, 0x71, 0x00, 0x00,
}
