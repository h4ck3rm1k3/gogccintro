package main
import "./ast/proto"

type GccNode Peg {

}
TUFILE <- ws Statement+ EOF

ws <- [ \t\r\n]*

NodeType <- < "addr_expr" /
"array_ref"/
"array_type" /
"asm_expr" /
"bind_expr"/
"binfo" /
"bit_and_expr"/
"bit_field_ref"/
"bit_ior_expr"/
"bit_not_expr"/
"bit_xor_expr"/
"boolean_type" /
"call_expr"/
"case_label_expr"/
"complex_type"/
"component_ref" /
"component_ref"/
"compound_expr"/
"cond_expr"/
"const_decl"/
"constructor" /
"convert_expr"/
"decl_expr"/
"enumeral_type" /
"eq_expr"/
"error_mark" /
"field_decl" /
"function_decl" /
"function_type" /
"ge_expr"/
"goto_expr"/
"gt_expr"/
"identifier_node" /
"indirect_ref"/
"integer_cst" /
"integer_type"/
"label_decl"/
"label_expr"/
"le_expr"/
"lshift_expr"/
"lt_expr"/
"mem_ref"/
"minus_expr"/
"modify_expr"/
"mult_expr"/
"namespace_decl"/
"ne_expr"/
"negate_expr"/
"nop_expr"/
"offset_type" /
"parm_decl"/
"plus_expr"/
"pointer_bounds_type"/
"pointer_plus_expr"/
"pointer_type" /
"postdecrement_expr"/
"postincrement_expr"/
"predecrement_expr"/
"predict_expr"/
"preincrement_expr"/
"real_type"/
"record_type" /
"reference_type" /
"result_decl" /
"return_expr"/
"rshift_expr"/
"save_expr" /
"save_expr"/
"statement_list"/
"string_cst" /
"string_cst"/
"switch_expr"/
"target_expr"/
"template_type_parm" /
"translation_unit_decl" /
"tree_list"/
"trunc_div_expr"/
"trunc_mod_expr"/
"truth_and_expr"/
"truth_andif_expr"/
"truth_or_expr"/
"truth_orif_expr"/
"type_decl" /
"type_decl"/
"typename_type"/
"union_type"/
"var_decl" /
"var_decl"/
"vector_type"/
"void_type"

> {
	s := astproto.NodeType(astproto.NodeType_value[buffer[begin:end]])
	NodeType=s
}

OpAttr <- "op " <[0-9]> {
    OpNumber = Atoi(buffer[begin:end])
    FieldName="opn"
    //fmt.Printf("op check1 %s %d\n", string(buffer[begin:end]), OpNumber)    
}


LineNumber <- <Integer> {
   LineNum = Atoi(buffer[begin:end])
}

FileName <- < ( [\-A-Za-z0-9_]+ ('.' [A-Za-z_]+)* / "<built-in>") >{
	FileName=string(buffer[begin:end])
}

FileRef <- ('_'? < FileName> ) ':' <LineNumber> ws {
	//fmt.Printf("FileName and Number: '%s:%d'\n",FileName, LineNum)
	getNode().AddFileRef(FileName,LineNum)
}

SourceAttr <-  <'srcp'> ':' ws <FileRef > # handled in fileref

IntAttr    <-  <("bases"/"used"/"prec")> ws ':' ws <Integer> ws {
	// base
	getNode().AddIntField(FieldName,buffer[begin:end])
}


#/0x0|[\-@]?1/
    
#IntAttrLow  <-  <("low" )> ws ':' ws ([\-0-9@xa-h]+) ws {
IntAttrLow  <-  <("low" )> ws ':' ws (HexValue/Node/NegInt/Integer) ws {
    // getNode().AddLowIntField("low",buffer[begin:end])
	//fmt.Printf("low %s\n",buffer[begin:end])
	if FieldType == TNodeRef {
		getNode().AddNodeRef("low",NodeNumber)
	} else if FieldType == TInteger {
		getNode().AddIntField("low",IntVal)	
	} else if FieldType == THex {
		getNode().AddHexField("low",HexVal)	
	} else {
		fmt.Printf("unkown field type : %s\n",buffer[begin:end])
		fmt.Printf("unkown field type : %s\n",buffer[begin-30:end+30])
		//panic("unkown field")
		getNode().AddHexField("low",buffer[begin:end])	
	}
    
}

IntAttr3    <-  <("high")> ws ':' ws <'-'? Integer> ws {
    getNode().AddIntField(FieldName,buffer[begin:end])	
}

Addr <- (DecimalDigit/Hex)+

	AddrAttr   <-  (<"addr:"> ws <Addr>) {
	// addr :
	getNode().AddHexField("addr",buffer[begin:end])
}

TagAttr   <-  ( <"tag"> ws ':' ws <("struct"/"union")>) {
	getNode().AddTag(astproto.TagType(astproto.TagType_value[buffer[begin:end]]))
}

BodyAttr   <-  (<"body"> ws ':' ws <("undefined"/ Node )>) {

}

LinkAttr <- ( <"link"> ws ':' ws <("extern"/"static")>) {
	getNode().AddLink(astproto.LinkType(astproto.LinkType_value[buffer[begin:end]]))
}

NoteAttr <- <"note"> ws ':' ws <("artificial"
/"member"/"ptrmem"/
"operator" ws (
"andassign"/
"and" /
"assign"/
"call"/
"delete" / 
"deref"/
"divassign" /
"div" /
"eq"/
"ge" /
"ge"/
"gt"/
"land"/
"le"/
"lnot"/
"lor"/
"lshiftassign" / 
"lshift"/
"lt"/
"minusassign" / 
"minus" / 
"multassign" / 
"mult" / 
"neg" / 
"new" /
"ne"/
"not" / 
"orassign" / 
"or"/
"plusassign"/
"plus" / 
"postdec" / 
"postinc" /
"pos" /
"predec" / 
"preinc"/
"ref" / 
"rshiftassign" /
"rshift"/
"subs" / 
"vecdelete" / 
"vecnew" / 
"xorassign" /
"xor"/
)?

/"pseudo tmpl"
/"destructor"
)> {
	getNode().AddNote(buffer[begin:end])
}
	
AccsAttr <- (<"accs"> ws ':' ws <("priv"/"pub"/"prot")>) {
	getNode().AddAccess(astproto.AccessType(astproto.AccessType_value[buffer[begin:end]]))
}
QualAttr <- (<"qual"> ws ':' ws (<("c"/"v"/"r")>)+ ws ) {
	getNode().AddQual(astproto.QualType(astproto.QualType_value[buffer[begin:end]]))
}

SignAttr   <-  (<"sign"> ws ':' ws <("signed"/"unsigned")>) {
	getNode().AddSign(astproto.SignType(astproto.SignType_value[buffer[begin:end]]))	
}

# field that references a node
NodeFieldName   <- < (
	   "retn" / "prms" /
	   "args" /
	   "base" /
	   "orig" /
	   "OP0" /	
	   "argt" /
	   "decl" /
	   	   "dcls" /	
	   "expr"/
	   "fncs" /
	   "fn"/
	   Integer /
    "cnst" /
    "cond" /
	   "vars" /
	   "vfld" /
	   "valu"/ "chan" / "purp" /
	   "refd" /
	   "flds" / 
	   "ptd" /
	   "cls" /
	   "csts" /
	   "labl" /
	   "type"/ "unql" /
	   "min"/"max"/
	   "binf"/
		"name"/"mngl"/
		"type"/ "scpe"/
	   "domn"/ "elts" /
	   "init" /
	   "chain" / "bpos" / "size"/"idx"/"val") > {

	       FieldName=buffer[begin:end]
    //fmt.Printf("set fieldname %s\n",FieldName) 
   }

NodeAttr   <- ws (NodeFieldName/OpAttr) ws ':' ws < Node >  ws {
    //fmt.Printf("node ref :'%s'\n",buffer[begin:end])
	//if NodeRefs == nil {
	//	NodeRefs = make(map [string] int)
	//}
	//NodeRefs[FieldName]=NodeNumber
	if FieldName == "opn" {
		getNode().AddOpNodeRef(FieldName,OpNumber,NodeNumber)
	}else {
		getNode().AddNodeRef(FieldName,NodeNumber)
	}
}

SpecValue  <- ws ("spec:")? ws (< ("mutable"/"bitfield"/"pure"/"virt"/"register" )> ws )+ {
	s := astproto.Spec( astproto.Spec_value[buffer[begin:end]] )
	getNode().AddSpec(s)
}
	

LngtAttr   <- "lngt" ws ':' ws < Integer > ws # skip this for now

RandomSpec <-  ws "spec" ws	   {}

OneAttr <- (StringAttr/SpecValue/NodeAttr/SourceAttr/IntAttr/SignAttr/IntAttr3/IntAttrLow/
	TagAttr/RandomSpec/
	BodyAttr/AccsAttr/
	NoteAttr/
	LinkAttr/
	QualAttr/IntAttr2/SignedIntAttr/LngtAttr/AddrAttr
	) {
FieldType=TUnknown
}
Attrs <- ( ws OneAttr )*
Attr <- ( OneAttr ws Attrs ws )?
Statement <- ( <Node> ws <NodeType> ws <Attr>) ws  {
	//fmt.Printf("stmt %#v\n",NodeRefs)

	// clear it
	//NodeRefs = make(map [string] int)
	n := getNode()
	n.NodeType=&NodeType
	file.AddNode(n)
	clearNode()
}


# String value 
# match a string like this :
#
#     strg : blah lngt: 4
#
# will not match the string containing "lngt:" in it, so might be a problem with the compiler files.

# this example won't work:
#
#    strg : lngt: lngt: 5
#

StringAttr <-  "strg: " 
 <
 	(
 	([^l])
 	/("l"[^n])
 	/("ln"[^g])
 	/("lng"[^t])
 	/("lngt"[^:])
 )+ 
  	> 
 &("lngt:")
 	{
// fmt.Printf("found string : bytes %d\n", end - begin)
//	fmt.Printf("found string : %s\n", buffer[begin:end])
    getNode().AddStringField(FieldName,buffer[begin:end])
    FieldType=TString
}


EOF <- !.

#Number

DecimalDigit <- [0-9] {}
NonZeroDecimalDigit <- [1-9] {}
Node <- '@' <NonZeroDecimalDigit DecimalDigit*>  {
	//s:=buffer[begin:end]
	//fmt.Printf("noderef %s\n",s)
    NodeNumber=Atoi(buffer[begin:end])
    FieldType=TNodeRef
}

PosInt   <- NonZeroDecimalDigit DecimalDigit* {}

Integer <- <'0' / PosInt > {
    IntVal=buffer[begin:end]
    FieldType = TInteger
}

Hex <- [a-h]
    
HexValue <- '0x' <(DecimalDigit/Hex)+ > {
    HexVal = string(buffer[begin:end])		
    FieldType = THex
}

NegInt   <- <'-' PosInt> {
// NegInt 
    IntVal=buffer[begin:end]
    FieldType = TInteger
}


SignedIntAttr    <-  "int:" ws (HexValue/NegInt/Integer)    {
	// int
	//fmt.Printf("signed check %s\n", string(buffer[0:end]))
//fmt.Printf("signed check %s\n", string(buffer[begin:end]))
	getNode().AddIntStringField(FieldName,buffer[begin:end])
}

IntAttr2    <-  <"algn"> ':' ws <[0-9]+> ws {
    // algn
    //fmt.Printf("algn %s\n", string(buffer[begin:end]))
    getNode().AddIntField("algn",buffer[begin:end])	
}
